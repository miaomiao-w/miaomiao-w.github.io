<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>TO DO LIST</title>
    <url>/2023/06/01/2000-01-01-to-do-list/</url>
    <content><![CDATA[<h2 id="to-do-list"><a href="#to-do-list" class="headerlink" title="to do list"></a>to do list</h2><p>欧拉角万向锁问题，欧拉角不适用于插值和迭代</p>
<p>奇异性，奇异矩阵</p>
<p>微分方程（李代数的引出中提及，此处尚未完全理解）</p>
<p>最小二乘</p>
<p>SLAM模型的引出</p>
<p>LIOSAM整个工程是怎么跑起来的</p>
<p>第一帧走了哪些流程，第二帧，第三帧呢</p>
]]></content>
  </entry>
  <entry>
    <title>书写，是为了铭记？还是忘记？</title>
    <url>/2019/02/28/2019-02-28-to-remember-or-not/</url>
    <content><![CDATA[<p>我从小语文成绩不好，却一直有写写划划的习惯。</p>
<p>年纪小的时候，思考的不多，看的书也不够多，那时候的写日记任务对于我来讲是一项挤牙膏般的折磨，输出不了；另一方面，感叹于世界的缤纷和多彩，有很多未知想要去探索，到处都是可以学习的地方。</p>
<p>但是又察觉到获取信息的方式的匮乏，所以那时就有摘录的习惯，报纸上、杂志上、课外书上、甚至于寒暑假作业上看到的知识点都想要记下来，或者抄录下来，或者直接剪下来贴在本上。家里有不少那时候留下来的本本。</p>
<p>所以，我喜欢记笔记，到了后来，又喜欢把看的书上的原句或者想法记录下来。我想，这些书写和记录，都是想要铭记，记住看过的东西，记住有过的想法，记住曾经的精彩。</p>
<p>上高中的时候，老师们经常说的一句话是，学习是先把书本读厚，然后再慢慢的读薄，你就真的是吃透了它了。</p>
<p>这话很好理解，越读越厚，是丰富了书本的知识点，所谓举一反三、融会贯通，这是不断累积的过程；而越读越薄，则是消化这些知识点，把他们自然融入到脑中的知识体系中，成为有机的一部分，这是真正习得的过程。</p>
<p>最近，和朋友开玩笑说这半年来思考的东西比前半生都多，关于亲情、爱情、工作、婚姻、家庭、生活、理想、意义等等。</p>
<p>话题多半是沉重和严肃的话题，想多了反而是都没有意义了。有心或无意，思考过的东西，存于脑中，或许不会一直占据脑海中心，时不时，总是会挠你一下，多了之后，难免不堪其扰。</p>
<p>这时候，经过有序的组织，写下来之后，仿佛是完成了一个又一个任务，可以放诸脑后，可以 move on 了，有迹可循就不怕忘记它，也就可以光明正大的忘记它，倒是真正轻松了很多。</p>
<p>这就像那个读书越读越薄的过程，占据的脑容量越来越小，不用想起，有可能是化成了另外一种形态。</p>
<p>那么，这些书写和抒发应该，是在整装待发，是要轻装上阵。</p>
<p><img src="/MD_IMG/2019-02-28-to-remember-or-not.assets/image-20230602220731398.png" alt="image-20230602220731398"></p>
]]></content>
      <categories>
        <category>随笔</category>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>你闻见过么？阳光的味道。</title>
    <url>/2019/09/07/2019-09-07-sunlight/</url>
    <content><![CDATA[<p>家在南方的人，想必都有这样一个印象：冬天，赶着天气放晴，阳光很好的时候，必然有那么几天会把家里的衣物被褥都翻出来，去见见太阳。</p>
<p>小的时候，在腊月里，总会赶着天儿好，在年前把屋里的棉衣袄子被褥床垫都拿到楼顶上去，甚至是床板都搬出去在庭前晒晒，见见光。</p>
<p>老妹说，我们姐弟仨都不喜欢干这件大事，虽说干活累且无趣，但是对我来讲，有一点点好，我喜欢闻这阳光的味道。</p>
<p>所以，可能，应该，我是家里收拾这些比较多的一个，比起老弟和老妹。</p>
<p>当爬到楼上，如果天公作美不下雨，如果时间老人不催赶，一般情况下，在收起之前，我都喜欢先凑上去，或者干脆躺在被子上，闻一闻那经过阳光洗浴后的味道，它不香不甜不热不腻也不是清新，而是一种生命力的味道，昂扬向上、欣欣向荣。</p>
<p>然后晚上睡觉的时候，就觉得自己被温暖包围了，睡在了阳光里。</p>
<p>后来大学毕业之后，研究生和工作上班都在北京，渐渐地这个习惯不知道怎么就没了，总认为，北方干燥，不像家里或者武汉那样潮湿，取而代之的，反而加湿器见得多了，以前爱开窗的习惯也没了。</p>
<p>少了一项大工程，但是也失了一点乐趣。</p>
<p>最近觉得，在这一亩三分地，住了快两年了，都没怎么折腾过，不行，突然就想动它一动。</p>
<p>生活就得折腾折腾。</p>
<p>正好，今天趁着周六休息和大太阳，把整个床都搬到三楼的阳台上去沐浴阳光，床垫子、褥子、被子、枕头、靠枕，还有我的娃娃们，该洗的全洗了，毛毯、床单、枕巾…</p>
<p>快夕阳西下了，一边在家里群里通着话，老爸，老妹，有一搭没一搭地唠着磕，一边收拾这些。</p>
<p>当我跑了整整三趟，把它们悉数抱了回来，然后再一点点把床铺好，枕巾盖上，靠枕摆上，把皮卡丘放在枕头边，棕色小熊待在另一角，白色熊熊随意放着。</p>
<p>它陪我最久，快七年了吧，小月买的，记得十分清楚，是大三的时候在武大门口那个超市的二楼一个饰品店，那时候还是个钢铁直女的我，不喜欢这些小女生喜欢的东西，但是也不知为啥鬼使神差一般，就要小月买来送给我。现在有时会抱着睡。</p>
<p>全都是旧物，重新回到它们原来的位置，心里升起了一股温暖和温馨。</p>
<p>就像今天的夕阳。</p>
<p><img src="/MD_IMG/2019-09-07-sunlight.assets/sunlight.jpg" alt="sunlight"></p>
]]></content>
      <categories>
        <category>随笔</category>
        <category>生活</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>SLAM数学基础（一）：向量与矩阵</title>
    <url>/2023/06/04/2023-06-04-vector/</url>
    <content><![CDATA[<h2 id="1-基础概念"><a href="#1-基础概念" class="headerlink" title="1 基础概念"></a>1 基础概念</h2><p><strong>点</strong>：点是空间中的基本元素，没有长度，没有体积。</p>
<p><strong>基</strong>：基（Basis）是张成一个空间的一组线性无关的向量（有些书中也叫基底）。一个空间的基是有任意多组，但一组基只能张成一个空间。</p>
<p><strong>向量</strong>：既有大小（长度），又有方向的量。向量用一般用<strong>有向线段</strong>来表示。（可以看成是从某点指向另一个点的箭头）</p>
<p>向量的本质是：空间中存在一定长度和方向的箭头。例如三维空间中，向量可以用三维坐标来表示，也可以用长度和角度（也就是极坐标）来表示。</p>
<p><strong>因此，向量的加减法、内外积，其结果与坐标系的选取无关，不讨论坐标时也是可以计算的。</strong></p>
<h2 id="2-空间向量"><a href="#2-空间向量" class="headerlink" title="2 空间向量"></a>2 空间向量</h2><h3 id="2-1-标准正交基"><a href="#2-1-标准正交基" class="headerlink" title="2.1 标准正交基"></a>2.1 标准正交基</h3><p><strong>正交基</strong>：在n维欧氏空间中，由n个向量组成的正交向量组（向量长度不为1）称为正交基（orthogonal bases）。</p>
<p><strong>标准正交基</strong>：在n维欧氏空间中，由n个单位向量组成的正交基称为标准正交基（Orthonormal Bases）。</p>
<p>标准正交基需要两个要素：正交(orthogonal 垂直)和标准（normal 长度为1）。</p>
<p><strong>标准正交基与坐标系</strong>：单位向量互相垂直构成坐标系。</p>
<p>标准正交基 $\boldsymbol{Q}$ 的<strong>重要性质</strong>：</p>
<ul>
<li>性质一：$\boldsymbol{Q}^T\boldsymbol{Q}&#x3D;I$ </li>
<li>性质二：$\boldsymbol{Q}^T &#x3D; \boldsymbol{Q}^{-1}$</li>
</ul>
<p>在一个线性三维空间中，$(\boldsymbol{e}_1, \boldsymbol{e}_2, \boldsymbol{e}_3)$是该空间的一组标准正交基，那么任意向量  $\boldsymbol{a}$ 在这组基下就有一个坐标：</p>
<p><img src="/MD_IMG/2023-06-04-vector.assets/image-20230604134043425.png" alt="image-20230604134043425"></p>
<p>这里$(a_1, a_2, a_3)^T$ 称为  $\boldsymbol{a}$ 在此基下的坐标。</p>
<p>向量坐标的具体取值，一是和向量本身有关，二是和坐标系（基）的选取有关。坐标系通常由3个正交的坐标轴组成（尽管也可以有非正交的，但实际中很少见）。</p>
<p>坐标系有右手系和左手系，大部分3D程序库使用右手系（如OpenGL、3DMax等），也有部分库使用左手系（如Unity、Direct3D等）。</p>
<h3 id="2-2-向量的内积"><a href="#2-2-向量的内积" class="headerlink" title="2.2 向量的内积"></a>2.2 向量的内积</h3><p>对于向量 $\boldsymbol{a},\boldsymbol{b}\in\mathbb{R}^3$通常意义下的内积可以写成:</p>
<p><img src="/MD_IMG/2023-06-04-vector.assets/image-20230604150443001.png" alt="image-20230604150443001"></p>
<p>内积可以描述向量间的投影关系。</p>
<h3 id="2-3-向量的外积"><a href="#2-3-向量的外积" class="headerlink" title="2.3 向量的外积"></a>2.3 向量的外积</h3><p>对于向量 $\boldsymbol{a},\boldsymbol{b}\in\mathbb{R}^3$，外积公式如下（$(\boldsymbol{i}, \boldsymbol{j}, \boldsymbol{k})$是一组基）：</p>
<p><img src="/MD_IMG/2023-06-04-vector.assets/image-20230604150651679.png" alt="image-20230604150651679"></p>
<ul>
<li>外积的方向：垂直于这两个向量</li>
<li>外积的大小：$\vert\boldsymbol{a}\vert\vert\boldsymbol{b}\vert\sin\langle\boldsymbol{a},\boldsymbol{b}\rangle$，即：两个向量张成的四边形的有向面积。</li>
</ul>
<h2 id="3-一些特殊矩阵"><a href="#3-一些特殊矩阵" class="headerlink" title="3 一些特殊矩阵"></a>3 一些特殊矩阵</h2><h3 id="3-1-反对称矩阵"><a href="#3-1-反对称矩阵" class="headerlink" title="3.1 反对称矩阵"></a>3.1 反对称矩阵</h3><p>上述表述中，其实目的是把向量外积改写成矩阵和向量的乘法，而这是一个线性运算，这对我们是有帮助的。公式中引入了一个符号 ^，把向量 $\boldsymbol{a}$ 写成一个矩阵，事实上这个矩阵是一个<strong>反对称矩阵（Skew-symmetric Matrix）</strong>，可记为 $\boldsymbol{a}$^，符号 ^ 可记为反对称符号。</p>
<ul>
<li><p>向量 $\boldsymbol{a}$ 的反对称矩阵为：$\boldsymbol{a}$^</p>
<p><img src="/MD_IMG/2023-06-04-vector.assets/image-20230604162113634.png" alt="image-20230604162113634"></p>
</li>
<li><p>反对称符号是一个一一映射，任意向量都对应着唯一的一个反对称矩阵，反之亦然</p>
</li>
<li><p>记反对称矩阵 $\boldsymbol{a}$^ &#x3D; $\boldsymbol{A}$ ，则 $\boldsymbol{A}$ 满足 $\boldsymbol{A}^T&#x3D;-\boldsymbol{A}$ ，或记为： $\boldsymbol{A} &#x3D; -\boldsymbol{A}^T$.</p>
</li>
</ul>
<h3 id="3-2-正交矩阵"><a href="#3-2-正交矩阵" class="headerlink" title="3.2 正交矩阵"></a>3.2 正交矩阵</h3><p><code>&lt;TODO&gt;</code></p>
<h3 id="3-3-投影矩阵"><a href="#3-3-投影矩阵" class="headerlink" title="3.3 投影矩阵"></a>3.3 投影矩阵</h3><p><code>&lt;TODO&gt;</code></p>
<h2 id="4-SLAM数学基础-系列笔记"><a href="#4-SLAM数学基础-系列笔记" class="headerlink" title="4 SLAM数学基础*系列笔记"></a>4 SLAM数学基础*系列笔记</h2><ul>
<li><p><a href="https://miaomiao-w.github.io/2023/06/04/2023-06-04-vector/">SLAM数学基础（一）：向量与矩阵</a></p>
</li>
<li><p><a href="https://miaomiao-w.github.io/2023/06/05/2023-06-05-transform/">SLAM数学基础（二）：坐标转换</a></p>
</li>
<li><p><a href="https://miaomiao-w.github.io/2023/06/07/2023-06-07-probability/">SLAM数学基础（三）：概率论基础概念及相关公式</a></p>
</li>
<li><p><a href="https://miaomiao-w.github.io/2023/06/12/2023-06-12-MLE/">SLAM数学基础（四）：理解极大似然估计</a></p>
</li>
<li><p><a href="https://miaomiao-w.github.io/2023/06/19/2023-06-19-MAP/">SLAM数学基础（五）：理解最大后验概率估计</a></p>
</li>
<li><p><a href="https://miaomiao-w.github.io/2023/06/20/2023-06-20-LSM/">SLAM数学基础（六）：最小二乘法</a></p>
</li>
</ul>
<p align="center">---END---</p>

<hr>
<hr>
<blockquote>
<p>高翔、张涛等著《视觉SLAM十四讲》</p>
<p><a href="https://zhuanlan.zhihu.com/p/162732832">https://zhuanlan.zhihu.com/p/162732832</a> </p>
</blockquote>
]]></content>
      <categories>
        <category>SLAM</category>
        <category>SLAM数学基础</category>
      </categories>
      <tags>
        <tag>SLAM数学基础</tag>
        <tag>向量</tag>
        <tag>特殊矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title>SLAM数学基础（二）：坐标转换</title>
    <url>/2023/06/05/2023-06-05-transform/</url>
    <content><![CDATA[<h2 id="1-坐标转换矩阵"><a href="#1-坐标转换矩阵" class="headerlink" title="1 坐标转换矩阵"></a>1 坐标转换矩阵</h2><h3 id="1-1-旋转矩阵"><a href="#1-1-旋转矩阵" class="headerlink" title="1.1 旋转矩阵"></a>1.1 旋转矩阵</h3><p>旋转矩阵描述了一个旋转过程，可以用它来表示两个坐标系之间的旋转变换。也叫方向余弦矩阵。</p>
<p>相关性质：</p>
<ul>
<li>旋转矩阵 $\boldsymbol{R}$ 是一个正交矩阵，且行列式为1（反之，行列式为1的正交矩阵就是一个旋转矩阵）；</li>
<li>旋转矩阵 $\boldsymbol{R}$ 的转置（也即 $\boldsymbol{R}$ 的逆，因为对于正交矩阵， $\boldsymbol{R}^{-1}&#x3D;\boldsymbol{R}^T$ ）刻画了一个相反的旋转；</li>
<li>对加法不封闭，也就是说，对于任意两个旋转矩阵，按照矩阵加法定义相加，其结果不再是一个旋转矩阵；</li>
<li>乘法封闭；</li>
</ul>
<p>三维旋转矩阵构成了特殊正交群$\boldsymbol{SO(3)}$。后续详述。</p>
<h3 id="1-2-变换矩阵"><a href="#1-2-变换矩阵" class="headerlink" title="1.2 变换矩阵"></a>1.2 变换矩阵</h3><p>变换矩阵描述了一个欧式变换过程，包含旋转 $\boldsymbol{R}$ 和平移 $\boldsymbol{t}$ 。</p>
<p>为方便书写和计算，将一次欧式变换中的旋转 $\boldsymbol{R}$ 和平移 $\boldsymbol{t}$ 写成变换矩阵 $\boldsymbol{T}$ 形式，向量坐标写成齐次坐标形式。</p>
<img src="MD_IMG/2023-06-05-transform.assets/image-20230605152752584.png" alt="image-20230605152752584" style="zoom: 60%;" />

<p><strong>相关性质</strong>：</p>
<ul>
<li><p>变换矩阵 $\boldsymbol{T}$ 中的旋转矩阵 $\boldsymbol{R}$ 如前所述，其相关性质依然具备；</p>
</li>
<li><p>两次变换的叠加可表示为变换矩阵的乘法：</p>
</li>
</ul>
<p>$$<br>\boldsymbol{b}&#x3D;\boldsymbol{T}_1\boldsymbol{a}, \boldsymbol{c}&#x3D;\boldsymbol{T}_2\boldsymbol{b},\qquad\Rightarrow \qquad\boldsymbol{c}&#x3D;\boldsymbol{T}_2\boldsymbol{T}_1\boldsymbol{a},<br>$$</p>
<ul>
<li>对加法不封闭，也就是说，对于任意两个变换矩阵，按照矩阵加法定义相加，其结果不再是一个变换矩阵；</li>
<li>乘法封闭；</li>
</ul>
<p>三维空间下的变换矩阵构成了特殊欧式群$\boldsymbol{SE(3)}$。后续详述。</p>
<h2 id="2-李群与李代数"><a href="#2-李群与李代数" class="headerlink" title="2 李群与李代数"></a>2 李群与李代数</h2><h3 id="2-1-何为群？"><a href="#2-1-何为群？" class="headerlink" title="2.1 何为群？"></a>2.1 何为群？</h3><p><strong>群（Group）</strong>是<strong>一种集合</strong>加上<strong>一种运算</strong>的代数结构。</p>
<p>集合记为 $A$ ，运算记为 $\cdot{}$  ，那么群可以记作 $G&#x3D;(A,\ \dot{}\ )$ 。群要求集合 $A$ 和运算 $\cdot{}$  满足以下条件：</p>
<ul>
<li>封闭性： $\forall{}a_1,a_2\in{}A，\qquad\ a_1\cdot{}a_2\in{}A$</li>
<li>结合律： $\forall{}a_1,a_2,a_3\in{}A，\quad(a_1\cdot{}a_2)\cdot{}a_3 &#x3D;a_1\cdot{}\ (a_2\cdot{}a_3)$</li>
<li>幺元：     $\exists{}a_0\in{}A,\qquad{}s.t.;\forall{}a\in{}A,\qquad{}a_0\cdot{}a&#x3D;a\cdot{}a_0&#x3D;a$</li>
<li>逆：         $\forall{}a\in{}A,\qquad{}\exists{}a^{-1}\in{}A,\qquad{}s.t.;a\cdot{}a^{-1}&#x3D;a$</li>
</ul>
<p><strong>常见的群：</strong></p>
<ul>
<li>整数的加法                       $G&#x3D;(\mathbb{Z},+)$</li>
<li>去掉0后的有理数的乘法  $G&#x3D;(\mathbb{Q}\setminus0,\cdot{})$</li>
</ul>
<p><strong>常见的矩阵中的群：</strong></p>
<ul>
<li>一般线性群 $GL(n)$   指 $n\times{}n$ 的可逆矩阵，他们对矩阵乘法成群。</li>
<li>特殊正交群 $SO(n)$   也就是所谓的旋转矩阵群，其中$SO(2)$和$SO(3)$最为常见。</li>
<li>特殊欧式群 $SE(n)$   也就是前面提到的n维欧氏变换，如$SE(2)$和$SE(3)$ 。</li>
</ul>
<h3 id="2-2-何为李群"><a href="#2-2-何为李群" class="headerlink" title="2.2 何为李群"></a>2.2 何为李群</h3><p>李群是指具有连续（光滑）性质的群。</p>
<p>类似整数群 $\mathbb{Z}$ 那样离散的群没有连续性质，所以不是李群。</p>
<p>$SO(n)$ 和 $SE(n)$ 在实数空间上是连续的。我们能够直观地想象一个刚体能够连续地在空间中运动，所以它们都是李群。</p>
<h3 id="特殊正交群SO-3"><a href="#特殊正交群SO-3" class="headerlink" title="特殊正交群SO(3)"></a>特殊正交群SO(3)</h3><h3 id="特殊欧式群SE-3"><a href="#特殊欧式群SE-3" class="headerlink" title="特殊欧式群SE(3)"></a>特殊欧式群SE(3)</h3><h3 id="李代数的理解"><a href="#李代数的理解" class="headerlink" title="李代数的理解"></a>李代数的理解</h3><h2 id="3-补充知识点"><a href="#3-补充知识点" class="headerlink" title="3 补充知识点"></a>3 补充知识点</h2><p>记 $\ast{}$ 是非空集合 $S$ 上的二元运算：</p>
<ul>
<li><p><strong>幺元</strong>（也称单位元），当：</p>
<p> $\exists{}e\in{}S,\qquad{}s.t.;\forall{}x\in{}S,\qquad{}e\ast{}x&#x3D;x\ast{}e&#x3D;x$ ，那么就称 $e$ 是 $(S,*)$ 的幺元。</p>
<p>幺元具有不变性。</p>
<p>【举例】：</p>
<p>实数集合 $\mathbb{R}$ 上的加法运算中，0就是幺元；</p>
<p>实数集合 $\mathbb{R}$ 上的乘法运算中，1就是幺元。</p>
</li>
<li><p><strong>零元</strong>，当：</p>
<p>$\exists{}o\in{}S,\qquad{}s.t.;\forall{}x\in{}S,\qquad{}o\ast{}x&#x3D;x\ast{}o&#x3D;o$ ，那么就称 $o$ 是 $(S,*)$ 的零元。</p>
<p>【举例】实数乘法运算中，零元就是对任意元x，都有xa&#x3D;ax&#x3D;a，则a为零元，因此0即为零元。</p>
</li>
<li><p><strong>逆元</strong>，当：</p>
<p>$\forall{}a\in{}S,\qquad{}s.t.;\exists{}b\in{}S,\qquad{}a\ast{}b&#x3D;b\ast{}a&#x3D;e$ ，那么 $a$ 和 $b$ 互为逆元， $a$ 是 $b$ 的逆元，同时 $b$ 是 $a$ 的逆元。</p>
<p>【举例】实数乘法运算中，互为倒数的两个数互称逆元，2和1&#x2F;2互为逆元，1和其本身互为逆元;</p>
</li>
</ul>
<h2 id="4-SLAM数学基础-系列笔记s"><a href="#4-SLAM数学基础-系列笔记s" class="headerlink" title="4 SLAM数学基础*系列笔记s"></a>4 SLAM数学基础*系列笔记s</h2><ul>
<li><p><a href="https://miaomiao-w.github.io/2023/06/04/2023-06-04-vector/">SLAM数学基础（一）：向量与矩阵</a></p>
</li>
<li><p><a href="https://miaomiao-w.github.io/2023/06/05/2023-06-05-transform/">SLAM数学基础（二）：坐标转换</a></p>
</li>
<li><p><a href="https://miaomiao-w.github.io/2023/06/07/2023-06-07-probability/">SLAM数学基础（三）：概率论基础概念及相关公式</a></p>
</li>
<li><p><a href="https://miaomiao-w.github.io/2023/06/12/2023-06-12-MLE/">SLAM数学基础（四）：理解极大似然估计</a></p>
</li>
<li><p><a href="https://miaomiao-w.github.io/2023/06/19/2023-06-19-MAP/">SLAM数学基础（五）：理解最大后验概率估计</a></p>
</li>
<li><p><a href="https://miaomiao-w.github.io/2023/06/20/2023-06-20-LSM/">SLAM数学基础（六）：最小二乘法</a></p>
</li>
</ul>
<hr>
<blockquote>
<p>高翔、张涛等著《视觉SLAM十四讲》</p>
</blockquote>
]]></content>
      <categories>
        <category>SLAM</category>
        <category>SLAM数学基础</category>
      </categories>
      <tags>
        <tag>SLAM数学基础</tag>
        <tag>旋转矩阵</tag>
        <tag>变换矩阵</tag>
        <tag>李群</tag>
        <tag>李代数</tag>
        <tag>特殊正交群</tag>
        <tag>特殊欧式群</tag>
      </tags>
  </entry>
  <entry>
    <title>SLAM数学基础（三）：概率论基础概念及相关公式</title>
    <url>/2023/06/07/2023-06-07-probability/</url>
    <content><![CDATA[<h2 id="0-写在前面"><a href="#0-写在前面" class="headerlink" title="0 写在前面"></a>0 写在前面</h2><p>这不是一个深入浅出的入门讲解。</p>
<p>实在是因为本人苦于各种公式概念傻傻分不清楚，看了一遍一遍又边看边忘，想要时不时捋一捋。</p>
<h2 id="1-条件概率与独立性"><a href="#1-条件概率与独立性" class="headerlink" title="1 条件概率与独立性"></a>1 条件概率与独立性</h2><p><strong>条件概率</strong>：设有两个事件 $A, B$, 而 $P(B)\neq{} 0$. 则“在给定 $B$ 发生的情况下 $A$ 发生的条件概率”，记为 $P(A\vert{}B)$，定义为</p>
<p><img src="/MD_IMG/2023-06-07-probability.assets/image-20230607200205028.png" alt="image-20230607200205028"></p>
<p><strong>独立</strong>：两个事件 $A, B$ 若满足 $P(AB) &#x3D; P(A)P(B)$，则称 $A, B$ 独立。</p>
<p><img src="/MD_IMG/2023-06-07-probability.assets/image-20230607200231761.png" alt="image-20230607200231761"></p>
<p><strong>概率乘法定理</strong>： 若干个独立事件之积的概率，等于各事件的概率之乘积，即：</p>
<p><img src="/MD_IMG/2023-06-07-probability.assets/image-20230607200145134.png" alt="image-20230607200145134"></p>
<p><strong>全概率公式</strong>：</p>
<p><img src="/MD_IMG/2023-06-07-probability.assets/image-20230607200133322.png" alt="image-20230607200133322"></p>
<p><strong>贝叶斯公式</strong>：在全概率公式的假定下，有：</p>
<p><img src="/MD_IMG/2023-06-07-probability.assets/image-20230607200340184.png" alt="image-20230607200340184"></p>
<h2 id="2-概率分布"><a href="#2-概率分布" class="headerlink" title="2 概率分布"></a>2 概率分布</h2><h3 id="2-1-离散型随机变量"><a href="#2-1-离散型随机变量" class="headerlink" title="2.1 离散型随机变量"></a>2.1 离散型随机变量</h3><p>需要区分概率分布与分布函数。</p>
<p><strong>概率函数</strong>：</p>
<p>概率函数（离散型） 设 <strong>X</strong> 为离散型随机变量，其全部可能值为{<em>a<del>1</del> , a<del>2</del> ,</em> ···}，则其概率函数为：</p>
<p><img src="/MD_IMG/2023-06-07-probability.assets/image-20230607232744751.png" alt="image-20230607232744751"></p>
<p>上式称为随机变量 <strong>X</strong> 的<strong>概率分布</strong>。</p>
<p>概率分布，其实严格意义来说，应该叫做”<strong>离散型随机变量的值分布和概率分布</strong>“，强调分布。</p>
<p><strong>概率分布函数</strong>：</p>
<p><img src="/MD_IMG/2023-06-07-probability.assets/image-20230607233026312.png" alt="image-20230607233026312"></p>
<p><strong>伯努利分布（Bernoulli）</strong>：</p>
<p>伯努利分布是关于布尔变量 $x\in {0,1}$ 的概率分布，其连续参数 $p \in [0,1]$ 表示变量 $x&#x3D;1$ 的概率。</p>
<p>直观理解就是扔一次硬币，要不正面要不背面，如果是标准的硬币 p&#x3D;0.5 。</p>
<p>$$<br>P(x\vert{}p)&#x3D;p^x(1−p)^{1−x}\\<br>E(x)&#x3D;p,  var(x)&#x3D;p(1−p)<br>$$</p>
<p><strong>二项分布（Binomial）</strong>：</p>
<p>二项分布就是重复 <em>n</em> 次独立的伯努利试验。</p>
<p>若随机变量 X 的可能取值为0, 1, ···, n，且概率分布为</p>
<p><img src="/MD_IMG/2023-06-07-probability.assets/image-20230607234346009.png" alt="image-20230607234346009"></p>
<p>则称 X 服从二项分布，记为 <img src="/MD_IMG/2023-06-07-probability.assets/image-20230607234452556.png" alt="image-20230607234452556"></p>
<p>延展：泊松分布、超几何分布、负二项分布</p>
<h3 id="2-2-连续型随机变量"><a href="#2-2-连续型随机变量" class="headerlink" title="2.2 连续型随机变量"></a>2.2 连续型随机变量</h3><p><strong>概率密度函数</strong>与<strong>分布函数</strong>:</p>
<p>记分布函数为$F(x)$，记概率密度函数为$f(x)$，则有：</p>
<p><img src="/MD_IMG/2023-06-07-probability.assets/image-20230607235218630.png" alt="image-20230607235218630"></p>
<p>并且连续型概率密度函数有以下性质：</p>
<p>（1） <img src="/MD_IMG/2023-06-07-probability.assets/image-20230607235435509.png" alt="image-20230607235435509"></p>
<p>（2）<img src="/MD_IMG/2023-06-07-probability.assets/image-20230607235458144.png" alt="image-20230607235458144"></p>
<p>（3）对于任何常数 <em>a &lt; b</em>，有：</p>
<p><img src="/MD_IMG/2023-06-07-probability.assets/image-20230607235536259.png" alt="image-20230607235536259"></p>
<p><strong>正态分布</strong>：</p>
<p>正态随机变量 <strong>X</strong> ，记为 <img src="/MD_IMG/2023-06-07-probability.assets/image-20230607235838081.png" alt="image-20230607235838081"> </p>
<p>概率密度函数为：</p>
<p><img src="/MD_IMG/2023-06-07-probability.assets/image-20230607235919576.png" alt="image-20230607235919576"></p>
<p><strong>标准正态分布</strong>：</p>
<p>标准正态随机变量 <strong>X</strong> ，<img src="/MD_IMG/2023-06-07-probability.assets/image-20230608000039126.png" alt="image-20230608000039126"> </p>
<p>概率密度函数为：</p>
<p><img src="/MD_IMG/2023-06-07-probability.assets/image-20230608000117309.png" alt="image-20230608000117309"></p>
<p><img src="/MD_IMG/2023-06-07-probability.assets/image-20230608000205752.png" alt="image-20230608000205752"> </p>
<p>延展：指数分布、均匀分布</p>
<h2 id="3-多维随机变量"><a href="#3-多维随机变量" class="headerlink" title="3 多维随机变量"></a>3 多维随机变量</h2><h3 id="3-1-多维随机变量（随机向量）"><a href="#3-1-多维随机变量（随机向量）" class="headerlink" title="3.1 多维随机变量（随机向量）"></a>3.1 多维随机变量（随机向量）</h3><p><strong>n 维随机变</strong>：</p>
<p>一般地，设 $X &#x3D; (X_1, X_2,  ··· , X_n)$ 为一个n 维向量，其每个分量都是一维随机变量。</p>
<p><strong>【离散型】</strong>：</p>
<p>以 ${a_{i1},a_{i2},}$记 $X_i$ 的全部可能值 $(i&#x3D;1,2,…)$ ，则事件 ${X_1&#x3D;a_{1j_1},\ …\ ,X_n&#x3D;a_{1nj_n},}$ 的概率</p>
<p><img src="/MD_IMG/2023-06-07-probability.assets/image-20230608234746142.png" alt="image-20230608234746142"></p>
<p>称为随机向量  $X &#x3D; (X_1, X_2,  ··· , X_n)$ 的概率函数或概率分布。</p>
<p>概率函数满足的条件：</p>
<p>（1）<img src="/MD_IMG/2023-06-07-probability.assets/image-20230608234910580.png" alt="image-20230608234910580"></p>
<p>（2）<img src="/MD_IMG/2023-06-07-probability.assets/image-20230608234926926.png" alt="image-20230608234926926"></p>
<p><strong>【连续型】</strong>：（？？）</p>
<p>若$f(x_1,…,x_n)$ 是定义在 $\mathbb{R}^n$ 上的非负函数，使对 $\mathbb{R}^n$ 中的任意集合  $A$, 有</p>
<p><img src="/MD_IMG/2023-06-07-probability.assets/image-20230608233817923.png" alt="image-20230608233817923"></p>
<p>则称 $f$ 是 $X$ 的概率密度函数。</p>
<p><strong>边缘分布和边缘概率密度</strong>：</p>
<p> 边缘分布其实就是多维随机变量中的其中一维随机变量的分布函数。</p>
<p>对于连续型而言，边缘分布如下<br>$$<br>F_X(x)&#x3D;F(x,∞)&#x3D;∫^x_{−∞}[∫^∞_{−∞}f(x,y)dy]dx<br>$$<br>有了边缘分布函数，自然有边缘概率密度函数，根据定义及上面的式子有<br>$$<br>f_X(x)&#x3D;∫^∞_{−∞}f(x,y)dy<br>$$<br> y的情况也相同。</p>
<p>事实上，我们根据二维正态分布的概率密度，求出其边缘概率密度，发现边缘概率密度正是一维正态分布的的概率密度。</p>
<p><strong>有关注意事项</strong>：<br>(1) 定义一维或者多维连续型随机变量时，实质都在于有概率密度函数存在。（有密度函数的随机变量）<br>(2) 连续型随机变量不能简单定义为“其各分量都是一维连续型随机变量的那种随机向量”。</p>
<h3 id="3-2-二维正态分布"><a href="#3-2-二维正态分布" class="headerlink" title="3.2 二维正态分布"></a>3.2 二维正态分布</h3><p>概率密度函数：</p>
<p><img src="/MD_IMG/2023-06-07-probability.assets/image-20230608235056886.png" alt="image-20230608235056886"></p>
<p>其中：</p>
<p><img src="/MD_IMG/2023-06-07-probability.assets/image-20230608235128283.png" alt="image-20230608235128283"></p>
<p>记为：</p>
<p><img src="/MD_IMG/2023-06-07-probability.assets/image-20230608235219900.png" alt="image-20230608235219900"></p>
<h2 id="4-SLAM数学基础-系列笔记"><a href="#4-SLAM数学基础-系列笔记" class="headerlink" title="4 SLAM数学基础*系列笔记"></a>4 SLAM数学基础*系列笔记</h2><ul>
<li><p><a href="https://miaomiao-w.github.io/2023/06/04/2023-06-04-vector/">SLAM数学基础（一）：向量与矩阵</a></p>
</li>
<li><p><a href="https://miaomiao-w.github.io/2023/06/05/2023-06-05-transform/">SLAM数学基础（二）：坐标转换</a></p>
</li>
<li><p><a href="https://miaomiao-w.github.io/2023/06/07/2023-06-07-probability/">SLAM数学基础（三）：概率论基础概念及相关公式</a></p>
</li>
<li><p><a href="https://miaomiao-w.github.io/2023/06/12/2023-06-12-MLE/">SLAM数学基础（四）：理解极大似然估计</a></p>
</li>
<li><p><a href="https://miaomiao-w.github.io/2023/06/19/2023-06-19-MAP/">SLAM数学基础（五）：理解最大后验概率估计</a></p>
</li>
<li><p><a href="https://miaomiao-w.github.io/2023/06/20/2023-06-20-LSM/">SLAM数学基础（六）：最小二乘法</a></p>
</li>
</ul>
<p align="center">---END---</p>

<hr>
<hr>
<blockquote>
<p><a href="https://ustc-resource.github.io/USTC-Course/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/notes/index.html">USTC-Course: 中国科学技术大学课程资源</a></p>
<p>齐民友主编《概率论与数理统计》</p>
</blockquote>
]]></content>
      <categories>
        <category>SLAM</category>
        <category>SLAM数学基础</category>
      </categories>
      <tags>
        <tag>SLAM数学基础</tag>
        <tag>概率论</tag>
      </tags>
  </entry>
  <entry>
    <title>SLAM数学基础（四）：理解极大似然估计</title>
    <url>/2023/06/12/2023-06-12-MLE/</url>
    <content><![CDATA[<h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0 前言"></a>0 前言</h2><p>数理统计的基本问题是：根据样本所提供的信息，对总体的分布或者分布的数字特征等作出统计推断。</p>
<p>在数理统计中，极大似然估计法是点估计的一种方法，此外还有矩估计法。</p>
<p>极大似然原理：是人们从长期的实践经验中总结出来的，即，</p>
<p>一个已经发生的事件 A，如果我们推断出 <em>k</em> 导致 A 发生的概率最大，那么就推断导致事件 A 发生的原因是 <em>k</em> 。</p>
<p>这是极大似然估计法成立的基石。</p>
<h2 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1 问题描述"></a>1 问题描述</h2><p>有总体 $X$ ，它服从于一个参数为 $(\theta_1,\theta_2,\ …\ ,\theta_k)$ 的分布（该分布模型已知，但参数 $(\theta_1,\theta_2,\ …\ ,\theta_k)$ 未知，且正是我们的求解目标）。</p>
<p>从这个总体中，随机地且相互独立地抽取出样本集 $(X_1,X_2,\ …\ ,X_n)$ ，样本观测值为 $(x_1,x_2,\ …\ ,x_n)$ ，根据这个样本集信息来估计未知参数$(\theta_1,\theta_2,\ …\ ,\theta_k)$。</p>
<h2 id="2-分析与理解"><a href="#2-分析与理解" class="headerlink" title="2 分析与理解"></a>2 分析与理解</h2><p>既然这个总体的分布模型已知，只是参数未知，那么是可以写出这个模型的概率密度函数的，只不过这个函数中模型参数用符号 $\theta$ 表示，我们称之为总体 $X$ 的分布，记为 $F(x;\theta)$ ，当 $X$ 为连续型随机变量（为便于书写，此处暂不讨论离散型随机变量），其概率密度设为 $f(x;\theta)$ ，那么抽取到任意一个样本值为 $x_i$ 的样本 $X_i$ 的概率值为  $f(x_i;\theta)$ ，那么抽取到这个样本集的概率就是抽到每一个样本的概率值相乘（因为是相互独立），因此，记样本集 $(X_1,X_2,\ …\ ,X_n)$ 的联合概率为：</p>
<p>$$<br>L(\theta;x_1,\ …\ ,x_n)&#x3D;f(x_1;\theta)\ …\ f(x_n;\theta)&#x3D;\prod_{i&#x3D;1}^n{f(x_i;\theta)}<br>$$</p>
<p>注意，上式是关于 $\theta$ 的函数，其中的 $(x_1,x_2,\ …\ ,x_n)$ 是已知的，就是所抽取的样本集的观测值。这个函数反映的是在不同的参数取值 $θ$ 下，取得当前这个样本集的可能性，因此称为参数 $θ$ 相对于样本集的似然函数（likehood function）。记为 $L(θ)$ 。</p>
<p>回到问题描述中，我们现在已经抽到了这个样本，那为什么会抽到这个样本呢？凭什么就是它呢？从最容易接受的角度来描述，就是，因为抽到这个样本的概率大，所以我们抽到了它（总不至于，抽到这个样本的概率非常小，我就是一抽就抽到了它）。这里听起来有点拗口，停下来理解一下。其实这点就是极大似然估计法的基本思想。</p>
<p>当在随机的条件下获取了一个较大的样本，极大似然估计法的理论认为，在这个总体出现这个结果就是可能性最大的，that‘s why “极大似然”。</p>
<p>于是，就可以利用这点进行参数估计，将满足</p>
<p>$$<br>\hat\theta &#x3D; \arg \max(L(\theta))<br>$$</p>
<p>的 ${\theta}$ 取值 $\hat{\theta}$ 作为所求参数估计。</p>
<h2 id="3-一般求解步骤"><a href="#3-一般求解步骤" class="headerlink" title="3 一般求解步骤"></a>3 一般求解步骤</h2><p>（1）写出似然函数；</p>
<p>（2）对似然函数取对数，并整理；</p>
<p>（3）求导数，令导数为0，得到似然方程；</p>
<p>（4）解似然方程，得到的参数即为所求。</p>
<p>其中第二步取对数，是因为 $L(\theta)$ 表现为一些函数的连乘积，求 $\ln{}L(\theta)$ 会更加方便。</p>
<p><strong>Tips</strong>：其实要理解什么是极大似然估计是干什么的，到这里基本就可以了，后面是用更加严格的数学语言进行描述。</p>
<h2 id="4-数学定义"><a href="#4-数学定义" class="headerlink" title="4 数学定义"></a>4 数学定义</h2><h3 id="4-1-似然函数"><a href="#4-1-似然函数" class="headerlink" title="4.1 似然函数"></a>4.1 似然函数</h3><p><strong>似然函数定义</strong>：</p>
<p>设 $(X_1,X_2,\ …\ ,X_n)$ 是总体 $X$ 的样本，$(x_1,x_2,\ …\ ,x_n)$ 是样本观察值。称</p>
<p>$$<br>L(\theta)&#x3D;L(\theta;x_1,\ …\ ,x_n)&#x3D;<br>\begin{cases}<br>\prod_{i&#x3D;1}^n{p(x_i;\theta)} ,当X是离散型且其分布律为\ \  p(x;\theta)时;\\<br>\\<br>\prod_{i&#x3D;1}^n{f(x_i;\theta)} ,当X是连续型且其概率密度为f(x;\theta)时;<br>\end{cases}<br>$$</p>
<p>为似然函数。</p>
<p><strong>似然函数与概率密度函数</strong>：</p>
<p>（1）似然函数有其直观的意义。</p>
<p>取出样本$(X_1,X_2,\ …\ ,X_n)$ 可以理解为进行了n次随机试验，试验的结果为 $(x_1,x_2,\ …\ ,x_n)$ ，</p>
<p>当 $X$ 为离散型时，似然函数就是样本$(X_1,X_2,\ …\ ,X_n)$ 取值为 $(x_1,x_2,\ …\ ,x_n)$ 这一事件发生的概率；</p>
<p>当 $X$ 为连续型时，似然函数就是联合概率密度在 $(x_1,x_2,\ …\ ,x_n)$ 处的取值。</p>
<p>（2）似然函数与联合分布在形式上是一样的，但是含义不同。</p>
<p>似然函数是关于参数 ${\theta}$ 的函数；</p>
<p>联合分布是关于试验结果 $(x_1,x_2,\ …\ ,x_n)$ 的函数。</p>
<h3 id="4-2-极大似然估计值"><a href="#4-2-极大似然估计值" class="headerlink" title="4.2 极大似然估计值"></a>4.2 极大似然估计值</h3><p><strong>定义</strong>：</p>
<p>设 $L(\theta)&#x3D;L(\theta;x_1,\ …\ ,x_n)$ 是似然函数，若存在$\hat{\theta}&#x3D;\hat{\theta}(x_1,x_2,\ …\ ,x_n)$ 使得</p>
<p>$$<br>L(\hat{\theta})&#x3D;\max_{\theta\in\Theta}{L({\theta})}<br>$$</p>
<p>则称 $\hat{\theta}(x_1,x_2,\ …\ ,x_n)$ 是未知参数 ${\theta}$ 的极大似然估计值，</p>
<p>​        $\hat{\theta}(X_1,X_2,\ …\ ,X_n)$ 是未知参数 ${\theta}$ 的极大似然估计量。</p>
<p>极大似然估计值其实就是字面上的意思，似然函数取最大值时 ${\theta}$ 的值 $\hat{\theta}$  。这里望文生义是没有问题的。</p>
<h3 id="4-3-似然函数的重要性"><a href="#4-3-似然函数的重要性" class="headerlink" title="4.3  似然函数的重要性"></a>4.3  似然函数的重要性</h3><p>在统计学中，似然函数是表示参数取值给定一组观测数据的可能性大小的函数。它是参数的函数，给定某一组参数取值后，可以计算出这组参数下，观测数据出现的概率。</p>
<p>可以通过似然函数来选择最佳的参数估计值，通常使用最大似然估计法来进行参数估计。如前所述。</p>
<p>此外，在最大后验估计中，似然函数同样扮演着重要的角色，它是计算后验分布时的一部分。具体而言，在最大后验估计中，我们需要找到一个能够最大化后验分布的参数值，而后验分布可以通过似然函数和先验分布进行计算。</p>
<p>后验概率 $p(\theta\vert{}X)$ 通常由 $P(\theta\vert{}X)&#x3D;\frac{P(X\vert{}\theta)P(\theta)}{P(X)}$ 计算而得，其中 $P(X\vert{}\theta)$ 就是似然函数。</p>
<h2 id="5-EM算法"><a href="#5-EM算法" class="headerlink" title="5 EM算法"></a>5 EM算法</h2><p><code>&lt;TODO&gt;</code></p>
<h2 id="6-SLAM数学基础-系列笔记"><a href="#6-SLAM数学基础-系列笔记" class="headerlink" title="6 SLAM数学基础*系列笔记"></a>6 SLAM数学基础*系列笔记</h2><ul>
<li><p><a href="https://miaomiao-w.github.io/2023/06/04/2023-06-04-vector/">SLAM数学基础（一）：向量与矩阵</a></p>
</li>
<li><p><a href="https://miaomiao-w.github.io/2023/06/05/2023-06-05-transform/">SLAM数学基础（二）：坐标转换</a></p>
</li>
<li><p><a href="https://miaomiao-w.github.io/2023/06/07/2023-06-07-probability/">SLAM数学基础（三）：概率论基础概念及相关公式</a></p>
</li>
<li><p><a href="https://miaomiao-w.github.io/2023/06/12/2023-06-12-MLE/">SLAM数学基础（四）：理解极大似然估计</a></p>
</li>
<li><p><a href="https://miaomiao-w.github.io/2023/06/19/2023-06-19-MAP/">SLAM数学基础（五）：理解最大后验概率估计</a></p>
</li>
<li><p><a href="https://miaomiao-w.github.io/2023/06/20/2023-06-20-LSM/">SLAM数学基础（六）：最小二乘法</a></p>
</li>
</ul>
<hr>
<blockquote>
<p>齐民友主编《概率论和数理统计》</p>
</blockquote>
]]></content>
      <categories>
        <category>SLAM</category>
        <category>SLAM数学基础</category>
      </categories>
      <tags>
        <tag>SLAM数学基础</tag>
        <tag>极大似然估计</tag>
        <tag>MLE</tag>
      </tags>
  </entry>
  <entry>
    <title>SLAM数学基础（五）：理解最大后验概率估计</title>
    <url>/2023/06/19/2023-06-19-MAP/</url>
    <content><![CDATA[<h2 id="0-问题引出"><a href="#0-问题引出" class="headerlink" title="0 问题引出"></a>0 问题引出</h2><p>在前文《极大似然估计》中，基于极大似然原理，仅利用样本信息实现了对模型参数的估计。</p>
<p>极大似然原理的一个朴素认知，就是认为当前事件会发生，就是因为本身它发生的概率就比较大，那就干脆认为它发生的概率最大，基于这个前提来进行参数估计。</p>
<p>但是我们知道，一个随机事件的任何一种情况的出现都要考虑其概率，样本中出现频次最高的并不一定就是概率最大的那种情况，尤其是样本量较小的时候，这么这种情况下极大似然估计值是不是就不太可靠了呢？这个时候 ，如果有一些关于这个模型参数的初始信息（这个初始信息其实就是先验知识），当同时结合先验知识和样本信息来进行参数估计，是不是得到的结果的可信度更高一些？</p>
<h2 id="1-贝叶斯定理"><a href="#1-贝叶斯定理" class="headerlink" title="1 贝叶斯定理"></a>1 贝叶斯定理</h2><p>贝叶斯定理也叫贝叶斯公式、贝叶斯法则。</p>
<p>贝叶斯公式如下：</p>
<p>$$<br>P(A\vert{}B) &#x3D; \frac{P(B\vert{}A)\times P(A)}{P(B)}<br>$$</p>
<p>$P(A\vert{}B)$ 是在 $B$ 已经发生的条件下， $A$ 发生的概率；是一种条件概率。</p>
<p>$P(B\vert{}A)$ 是在 $A$ 已经发生的条件下， $B$ 发生的概率；也是条件概率。</p>
<p>$P(A)$ 是事件 $A$ 发生的概率。</p>
<p>$P(B)$ 是事件 $B$ 发生的概率。</p>
<p>上述公式的推导并不难，由</p>
<p>$$<br>P(A \cap B)&#x3D;P(B\vert{}A)\times P(A) \\<br>P(A \cap B)&#x3D;P(A\vert{}B)\times P(B)<br>$$</p>
<p>就可推出，但这不是重点，建立一种直观的理解才是更重要的。</p>
<hr>
<p>考虑并理解以下表述方式：</p>
<p>贝叶斯公式可以用来计算在给定某个观测结果的情况下，某个备选假设成立的概率。</p>
<p>设一个总体服从于某种分布，该分布模型参数为 $\theta$ ，$D$ 表示观测到的数据。根据贝叶斯公式，在给定数据 $D$ 下模型参数 $\theta$ 的概率分布：</p>
<p>$$<br>P(\theta\vert{}D) &#x3D; \frac{P(D\vert{}\theta)\times P(\theta)}{P(D)}<br>$$</p>
<p>其中，$P(\theta\vert{}D)$ 表示在已有数据 $D$ 的前提下，模型参数 $\theta$ 的概率分布，称为后验概率； $P(D\vert{}\theta)$ 是在模型参数为 $\theta$ 的前提下，观测到数据 $D$ 的概率（也称为似然函数，后面再讲）；</p>
<p> $P(\theta)$ 是模型参数 $\theta$ 的概率分布，称为先验概率；</p>
<p> $P(D)$ 表示观测到数据 $D$ 的概率。</p>
<p>后验概率是指在得到新的数据或信息后，重新计算某个事件发生的概率，即根据先前的经验和新的证据来更新我们的概率判断。</p>
<h2 id="2-贝叶斯公式中的似然函数理解"><a href="#2-贝叶斯公式中的似然函数理解" class="headerlink" title="2 贝叶斯公式中的似然函数理解"></a>2 贝叶斯公式中的似然函数理解</h2><p>上面提到， $P(D\vert{}\theta)$ 也称为似然函数，在数值上， $ P(D\vert{}\theta)&#x3D;L(\theta\vert{}D)$ ，</p>
<p>等式左边， $P(D\vert{}\theta)$ 其含义是在条件 $\theta$ 下观测到数据 $D$ 的概率，</p>
<p>等式右边， $L(\theta\vert{}D)$ 其含义是当已有观测数据 $D$ ，模型参数 $\theta$ 的似然。</p>
<p>为什么是这样呢？回顾似然函数的定义：</p>
<p><img src="/MD_IMG/2023-06-19-MAP.assets/image-20230620223556799.png" alt="image-20230620223556799"></p>
<p>所以事实上，我们这里说到的联合概率，以及前面的条件概率 $P(D\vert{}\theta)$ ，似然 $L(\theta\vert{}D)$ ，都是指同一个东西，形式上都是：</p>
<p>$$<br>p(x_1;\theta)p(x_2;\theta)…p(x_n;\theta)&#x3D;\prod_{i&#x3D;1}^n{p(x_i;\theta)}<br>$$</p>
<p>只不过，当模型参数 $\theta$ 已知时，它一般用来描述事件发生的概率，此时表述为条件概率或联合概率密度，着眼于“概率”；当模型参数 $\theta$ 未知时，这个式子一般就是用来估计模型参数 $\theta$ 的，此时被称为似然函数，是关于模型参数 $\theta$ 的函数，参数 $\theta$ 的估计方法一般有极大似然估计或最大后验估计（这两种方法也是频率学派和贝叶斯学派各自思想主张的具体体现之一，如果有时间再来总结对比吧）。</p>
<hr>
<p><strong>概率与似然的一种理解</strong>：</p>
<p>“概率”描述了给定模型参数后，描述结果的合理性，而不涉及任何观察到的数据。</p>
<p>“似然”描述了给定了特定观测值后，描述模型参数是否合理。</p>
<hr>
<p><strong>先验概率与后验概率的一种理解</strong>：</p>
<p>先验概率是 以全事件 $Ω$ 为背景下， $A$ 事件发生的概率， $P(A\vert{}Ω)$ 。</p>
<p>后验概率是 以新事件 $B$ 为背景下，$A$事件发生的概率， $P(A\vert{}B)$ 。</p>
<p>全事件一般是统计获得的，所以称为先验概率，是指没有实验前的概率，是普遍认可的先验知识（例如，硬币两面是均匀的）。</p>
<p>新事件一般是实验，如试验 $B$ ，现在是一个具体的情境了（例：我们现在手里有一个具体的硬币在做试验了），此时的事件背景从全事件变成了 $B$ ，该事件 $B$ 可能对 $A$ 的概率有影响，那么需要对$A$现在的概率进行一个修正，从 $P(A\vert{}Ω)$ 变成 $P(A\vert{}B)$ ，</p>
<p>所以称 $P(A\vert{}B)$ 为后验概率，也就是试验(事件$B$发生)后的概率，依据试验情况进行更新后的概率。</p>
<h2 id="3-最大后验概率MAP"><a href="#3-最大后验概率MAP" class="headerlink" title="3 最大后验概率MAP"></a>3 最大后验概率MAP</h2><p>讲到这里才真正说到最大后验概率估计，其实基本上已经说的差不多了。</p>
<p>最大后验概率（Maximum a posteriori probability，MAP）是一种用来描述随机事件的概率的统计方法。是贝叶斯推断中的一个重要方法，表示在给定观测值和先验信息时，得到最大后验概率的参数值。</p>
<p>在贝叶斯推断中，粗略地讲，对于一个已知的随机事件 $X$ 和其分布的先验知识 $P(\theta)$，其中 $\theta$ 是事件 $X$ 的未知参数，我们可以通过贝叶斯公式求出其后验概率 $P(\theta\vert{}X)$。具体而言，可以写作：</p>
<p>$$<br>P(\theta\vert{}X) &#x3D; \frac{P(X\vert{}\theta)P(\theta)}{P(X)}<br>$$</p>
<p> 其中，$P(X\vert{}\theta)$ 是已知参数 $\theta$ 下 $X$ 观测值的概率密度函数，称为似然函数；</p>
<p>$P(\theta)$ 是先验分布，即在进行观测前对未知参数 $\theta$ 的分布的了解；</p>
<p>$P(X)$ 是归一化常数，确保后验概率 $P(\theta\vert{}X)$ 的积分等于 $1$。</p>
<p>最大后验概率是指，在已知观测值 $X$ 和先验知识 $P(\theta)$ 的基础上，求出一个最有可能的参数 $\theta_{MAP}$，使得其后验概率 $P(\theta_{MAP}\vert{}X)$ 达到最大。即：</p>
<p>$$<br>\theta_{MAP} &#x3D; \underset{\theta}{\operatorname{argmax}} P(\theta\vert{}X)<br>$$</p>
<p>最大化后验概率求参数 $\theta$ 的估计值的方法，就是最大后验估计（MAP estimation）。</p>
<p>在一些数据较少且参数维度较高的问题中，最大后验估计算法相对于极大似然估计、普通最小二乘法等其他估计算法，能够通过先验概率信息有效避免过拟合和欠拟合等问题，提高模型的泛化能力。</p>
<p>当数据量或样本量非常大时，极大似然估计与最大后验估计是殊途同归的。</p>
<h2 id="4-SLAM数学基础-系列笔记"><a href="#4-SLAM数学基础-系列笔记" class="headerlink" title="4 SLAM数学基础*系列笔记"></a>4 SLAM数学基础*系列笔记</h2><ul>
<li><p><a href="https://miaomiao-w.github.io/2023/06/04/2023-06-04-vector/">SLAM数学基础（一）：向量与矩阵</a></p>
</li>
<li><p><a href="https://miaomiao-w.github.io/2023/06/05/2023-06-05-transform/">SLAM数学基础（二）：坐标转换</a></p>
</li>
<li><p><a href="https://miaomiao-w.github.io/2023/06/07/2023-06-07-probability/">SLAM数学基础（三）：概率论基础概念及相关公式</a></p>
</li>
<li><p><a href="https://miaomiao-w.github.io/2023/06/12/2023-06-12-MLE/">SLAM数学基础（四）：理解极大似然估计</a></p>
</li>
<li><p><a href="https://miaomiao-w.github.io/2023/06/19/2023-06-19-MAP/">SLAM数学基础（五）：理解最大后验概率估计</a></p>
</li>
<li><p><a href="https://miaomiao-w.github.io/2023/06/20/2023-06-20-LSM/">SLAM数学基础（六）：最小二乘法</a></p>
</li>
</ul>
<hr>
<blockquote>
<p>齐民友主编《概率论和数理统计》</p>
</blockquote>
]]></content>
      <categories>
        <category>SLAM</category>
        <category>SLAM数学基础</category>
      </categories>
      <tags>
        <tag>SLAM数学基础</tag>
        <tag>最大后验概率</tag>
        <tag>MAP</tag>
      </tags>
  </entry>
  <entry>
    <title>SLAM数学基础（六）：最小二乘法</title>
    <url>/2023/06/20/2023-06-20-LSM/</url>
    <content><![CDATA[<h2 id="1-最简单的最小二乘问题"><a href="#1-最简单的最小二乘问题" class="headerlink" title="1 最简单的最小二乘问题"></a>1 最简单的最小二乘问题</h2><p>先不考虑模型的适用场景，以及为什么要用这个方法，只从数学的角度，看这是一个什么问题。有如下数学模型：<br>$$<br>\min_{x}{F(x)}&#x3D;\frac{1}{2} \parallel{f(x)}\parallel_2^2<br>$$<br>最小二乘问题就是求满足上式的 $x$ 值。其中，自变量 $x\in\mathbb{R}^n$ ，$f$ 是任意标量非线性函数 $f(x):\mathbb{R}^n\mapsto\mathbb{R}$ 。注意这里的系数 $\frac{1}{2}$ 无关紧要，有没有都不会影响之后的结论。</p>
<p>拆解一下最小二乘，顾名思义，“二乘”就是指平方，“最小”指，要求的是函数 $F(x)$取最小值的时候 $x$ 的取值。当然，上面这个是最简单的一个最小二乘问题。</p>
<p>如果 $f$ 是个数学形式上很简单的函数，那么该问题可以用解析形式来求。令目标函数的导数为零： $\frac{dF}{dx}&#x3D;0$ ，然后求解 $x$ 的最优值，就和求二元函数的极值一样。解这个方程，就得到了导数为零处的极值。它们可能是极大、极小或鞍点处的值，只要逐个比较它们的函数值大小即可。</p>
<p>但是，这个方程是否容易求解呢？这取决于 $f$ 导函数的形式。如果 $f$ 为简单的线性函数，那么这个间题就是简单的线性最小二乘问题；但是有些导函数可能形式复杂，使得该方程可能不容易求解。求解这个方程需要我们知道关于目标函数的全局性质，而通常这是不大可能的。</p>
<p>对于不方便直接求解的最小二乘问题，可以用迭代的方式（到这里才是重点要了解学习的地方），从一个初始值出发，不断地更新当前的优化变量，使目标函数下降。对于最小二乘问题，有一阶和二阶梯度法（最速下降法、牛顿法），高斯牛顿法，列文伯格一马夸尔特法等，后两种实际应用较多，且高斯牛顿法最常用。</p>
<p>以上是最简单的模型情况，下面再来看最小二乘在一些实践中的应用。</p>
<h2 id="2-最小二乘的提出"><a href="#2-最小二乘的提出" class="headerlink" title="2 最小二乘的提出"></a>2 最小二乘的提出</h2><p>在生产实践中，经常会遇到利用一组观测数据来估计某些未知参数的问题。例如，一个做匀速直线运动的质点在时刻 $t$ 的位置是 $\hat{y}$ ，可以用如下的线性函数来描述：<br>$$<br>\hat{y}&#x3D;\hat{\alpha}+t\hat{\beta}<br>$$<br>式中， $\hat{\alpha}$ 是质点在$t&#x3D;0$时刻的初始位置， $\hat{\beta}$ 是平均速度，它们是待估计的未知参数，可见这类问题为线性参数的估计问题。对于这一问题，如果观测没有误差，则只要在两个不同时刻 $t_1$ 和 $t_2$ 观测出质点的相应位置 ${y_1}$ 和 ${y_2}$ ，由上述函数分别建立两个方程，就可以解出 $\hat{\alpha}$ 和 $\hat{\beta}$ 的值了。但是，实际上在观测时，考虑到观测值带有偶然误差，所以总是作多余观测。在这种情况下，为了求得 $\hat{\alpha}$ 和 $\hat{\beta}$ ，就需要在不同时刻 $t_1,t_2,\ …\ ,t_n$ 来测定其位置，得出一组观测值 $y_1,y_2,\ …\ ,y_n$ 这时，由上式可以得到：<br>$$<br>\delta{}_i&#x3D;\hat{\alpha}+t_i\ \hat{\beta}-y_i<br>$$<br>$\delta{}_i$ 为观测值 $y_i$ 与真值 $\hat{y_i}(&#x3D;\hat{\alpha}+t_i\ \hat{\beta})$ 的差值，即观测误差（或者成为残差）。由于观测误差的存在，由观测数据 $(t_i,y_i)$ 描绘不成直线，而有某些“摆动”。</p>
<p>这里就产生这样一个问题：用什么准则来对参数 $\hat{\alpha}$ 和 $\hat{\beta}$ 进行估计，从而使估计直线 $\hat{y}&#x3D;\hat{\alpha}+t\hat{\beta}$  “最佳”地拟合于各观测点？（哦对了，不要忘了，我们进行观测的目的是得到参数 $\hat{\alpha}$ 和 $\hat{\beta}$ 的估计值。）</p>
<p>这里的“最佳”一词可以有不同的理解。例如，</p>
<ul>
<li><p>可以认为：各观测点到直线最大距离取最小值时，直线是“最佳”的；</p>
</li>
<li><p>也可以认为，各观测点到直线的偏差的绝对值之和取最小值时，直线是“最佳”的，等等。</p>
</li>
</ul>
<p>在不同的“最佳要求下，可以求得相应问题中参数 $\hat{\alpha}$ 和 $\hat{\beta}$ 不同的估值。</p>
<p>早在19世纪，勒让德就认为依据“<strong>残差的平方和最小</strong>”估计出来的模型是最接近真实情形的。这也就是最小二乘原理，按照最小二乘原理的要求，认为“最佳”地拟合于各观测点的估计曲线，应使各观测点到该直线的偏差的平方和达到最小。</p>
<p>在众多的“最佳”中，为什么选择“<strong>残差的平方和最小</strong>”呢？这里暂且不表，后续再说。</p>
<h2 id="3-最小二乘的多维形式"><a href="#3-最小二乘的多维形式" class="headerlink" title="3 最小二乘的多维形式"></a>3 最小二乘的多维形式</h2><h2 id="4-最小二乘估计与极大似然估计"><a href="#4-最小二乘估计与极大似然估计" class="headerlink" title="4 最小二乘估计与极大似然估计"></a>4 最小二乘估计与极大似然估计</h2><h2 id="5-最小二乘问题的解法"><a href="#5-最小二乘问题的解法" class="headerlink" title="5 最小二乘问题的解法"></a>5 最小二乘问题的解法</h2><h2 id="6-SLAM数学基础-系列笔记"><a href="#6-SLAM数学基础-系列笔记" class="headerlink" title="6 SLAM数学基础*系列笔记"></a>6 SLAM数学基础*系列笔记</h2><ul>
<li><p><a href="https://miaomiao-w.github.io/2023/06/04/2023-06-04-vector/">SLAM数学基础（一）：向量与矩阵</a></p>
</li>
<li><p><a href="https://miaomiao-w.github.io/2023/06/05/2023-06-05-transform/">SLAM数学基础（二）：坐标转换</a></p>
</li>
<li><p><a href="https://miaomiao-w.github.io/2023/06/07/2023-06-07-probability/">SLAM数学基础（三）：概率论基础概念及相关公式</a></p>
</li>
<li><p><a href="https://miaomiao-w.github.io/2023/06/12/2023-06-12-MLE/">SLAM数学基础（四）：理解极大似然估计</a></p>
</li>
<li><p><a href="https://miaomiao-w.github.io/2023/06/19/2023-06-19-MAP/">SLAM数学基础（五）：理解最大后验概率估计</a></p>
</li>
<li><p><a href="https://miaomiao-w.github.io/2023/06/20/2023-06-20-LSM/">SLAM数学基础（六）：最小二乘法</a></p>
</li>
</ul>
<hr>
<p>当估计的变量是一个服从高斯分布的随机变量时，最小二乘可以由极大似然估计引出。此种情况下最小二乘估计和极大似然估计结果是一致的。</p>
<p>所以，最小二乘估计是极大似然估计的一种特例（？？？）。</p>
<p>服从高斯分布的随机变量由于服从正态分布有许多优雅的性质，因此广泛应用于工程实践中。不知道是不是错觉，极大似然估计多停留在数学层面，工程实践中最多的还是最小二乘估计。</p>
<hr>
<blockquote>
<p>高翔、张涛等著《视觉SLAM十四讲》</p>
<p>武汉大学测绘学院测量平差学科组编著《误差理论与测量平差基础》</p>
<p><a href="https://blog.csdn.net/MoreAction_/article/details/106443383"> 一文让你彻底搞懂最小二乘法—胤风的博客</a></p>
</blockquote>
]]></content>
      <categories>
        <category>SLAM</category>
        <category>SLAM数学基础</category>
      </categories>
      <tags>
        <tag>SLAM数学基础</tag>
        <tag>最小二乘法</tag>
        <tag>LSM</tag>
      </tags>
  </entry>
  <entry>
    <title>地面分割算法（一）：linefit_ground_segmentation</title>
    <url>/2023/06/23/2023-06-23-segmentation-01/</url>
    <content><![CDATA[<p>paper: <a href="https://ieeexplore.ieee.org/document/5548059/figures#figures">Fast segmentation of 3D point clouds for ground vehicles</a></p>
<p>Github: <a href="https://github.com/lorenwel/linefit_ground_segmentation">Github-lorenwel-linefit_ground_segmentation</a></p>
<h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1 简介"></a>1 简介</h2><p>这篇论文的算法是应用比较广泛的激光点云地面分割算法，在许多激光SLAM算法中都有引用。该论文方法效率高，且可以适用于具有一定坡度的地面。</p>
<p>算法中，将点云划分为多个扇区，一个扇区作为一个独立的处理单元。每个扇区再分成多个容器，每个容器取一个最低点，根据这些最低点拟合地面线，并以此为基础判断全部激光点是否为地面点，实现地面点云与非地面点云的分割。算法分为以下几个主要步骤：</p>
<ul>
<li><p>点云划分与映射</p>
</li>
<li><p>地面线段拟合</p>
</li>
<li><p>地面点云分割（地面点与非地面点判断）</p>
</li>
</ul>
<h2 id="2-点云结构化"><a href="#2-点云结构化" class="headerlink" title="2 点云结构化"></a>2 点云结构化</h2><p>点云结构化即：将一组无序的激光点云按照一定规则进行划分和映射，最终得到一组有序点云，也相当于是建立了索引，便于后续的算法处理。</p>
<ul>
<li>将激光点云按角度等间隔为 $N$ 个$Segment$（每个$Segment$为一个扇区），对于每个$Segment$ 按距离又等分$M$个$Bin$ （即容器），于是，每个点对应一个$(Segment,Bin)$；</li>
<li>对于每个三维点 $P(x,y,z)$ ，平面坐标用极坐标方式表示 $P(r,\theta,z)$ ，由于每个$Segment$ 内的点被认为角度一样，于是每个$Segment$ 内角度可以忽略，用二维点 $P(r,z)$ 表示，其中 $r&#x3D;\sqrt{x^2+y^2}$ ，相当于降维。</li>
<li>计算每个 $Bin$ 内的最低点 $MinZPoint(d,z)$ 。</li>
</ul>
<p><img src="/MD_IMG/2023-06-23-segmentation-01.assets/image-20230623225410411.png" alt="image-20230623225410411"></p>
<h2 id="3-地面线段拟合"><a href="#3-地面线段拟合" class="headerlink" title="3 地面线段拟合"></a>3 地面线段拟合</h2><h3 id="3-1-流程图"><a href="#3-1-流程图" class="headerlink" title="3.1 流程图"></a>3.1 流程图</h3><p>根据每个 $Bin$ 的最低点拟合地面线段 $GroundLine$ ，其论文理论部分相对简单，但代码逻辑相对复杂一些，原论文中的算法伪代码如下：</p>
<p><img src="/MD_IMG/2023-06-23-segmentation-01.assets/image-20230624172909256.png" alt="image-20230624172909256"></p>
<p>为更好地理解算法逻辑，下面为依据代码所做的流程图。提前进行如下说明：</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>binPoint</code></td>
<td>表示每个Bin中的最低点 <code>MinZPoint(d,z)</code></td>
</tr>
<tr>
<td><code>curBinPoint</code></td>
<td>当前循环中正在处理的 <code>binPoint</code></td>
</tr>
<tr>
<td><code>firstBinPoint</code></td>
<td>找到的第一个非空<code>bin</code>中的 <code>binPoint</code></td>
</tr>
<tr>
<td><code>非空bin</code></td>
<td>有激光点落入该<code>bin</code> 中则非空，<code>非空bin</code> 才有 <code>binPoint</code></td>
</tr>
<tr>
<td><code>linePoints</code></td>
<td>是一个<code>vector</code>，存储的是当前状态下，用于拟合局部地面线段的备选 <code>binPoint</code></td>
</tr>
<tr>
<td><code>lastBinPoint</code></td>
<td>上一个入选<code>linePoints</code>的 <code>binPoint</code>，<code>lastBinPoint=linePoints.back()</code></td>
</tr>
<tr>
<td><code>linePoints_size</code></td>
<td>上面<code>linePoints</code>这个<code>vector</code>的大小，也就是备选 <code>binPoint</code> 的点数量</td>
</tr>
<tr>
<td><code>localGroundLine</code></td>
<td>利用<code>linePoints</code>中的备选 <code>binPoint</code>拟合出的局部地面线段</td>
</tr>
<tr>
<td><code>groundLines</code></td>
<td>本算法的最终结果存储，是一个<code>vector</code>，里面元素为一个个线段，<br>每个线段实际保存两个点即可</td>
</tr>
</tbody></table>
<p>基于以上符号的含义来理解以下算法流程。为了便于理解整个算法，以下的判断条件多为简写，如<code>if curBinPoint valid</code>，<code>if localLine good</code> 等，具体的判断条件后文再具体分析，此处先提纲挈领地理解整个地面线段拟合的算法逻辑。</p>
<p>总的来说，需要带着两个问题：</p>
<ul>
<li>满足什么条件的点可以用来拟合地面线段？</li>
<li>什么条件下，地面线需要中断并重新开启一条线段（以符合不同坡度的地面情况）？</li>
</ul>
<p><img src="/MD_IMG/2023-06-23-segmentation-01.assets/image-20230624004950917.png" alt="image-20230624004950917"></p>
<p>以上流程中，同一颜色的框图代表相同或相近的含义：</p>
<ul>
<li>蓝：开始或转入一次循环；</li>
<li>橙：不同的判断条件；</li>
<li>绿：拟合地面线段（注意，并不是每次拟合的都是地面线段结果，效果不佳时要剔除相关点再拟合）；</li>
<li>黄：开始一条新的线。注意两种情况略有不同。<ul>
<li>第一种，有效点太少且又遇当前点为中断点，则删去前面的少量有效点，从中断点即当前点重新开始；</li>
<li>第二种实则又分为两种，一是前一个线段有效保存下来，二是前段依然有效点不够，但都是<code>lastBinPoint</code>作为中断点，与第一种情况<code>curBinPoint</code>为中断点略有不同（具体原因，前一个线段有效保存可以理解，但是前段有效点不够的情况似乎与第一种并无二致，原因暂未深究）；</li>
</ul>
</li>
<li>红：保存地面线段，注意，这个步骤<code>groundLines</code>存储的是我们本阶段的终极目标；</li>
<li>白：其他 less important 步骤，如<code>push、pop</code>等；</li>
<li>灰：算法起止。</li>
</ul>
<h3 id="3-2-判断条件"><a href="#3-2-判断条件" class="headerlink" title="3.2 判断条件"></a>3.2 判断条件</h3><ul>
<li><strong>if curBinPoint exists ?</strong> </li>
<li><strong>if linePoints_size ≥ n ？</strong></li>
</ul>
<p>这两个比较简单。</p>
<table>
<thead>
<tr>
<th>判断条件</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>if curBinPoint exists ? </code></td>
<td>有激光点落入该<code>bin</code> 中则非空，<br><code>非空bin</code> 有 <code>binPoint</code>，即<code>curBinPoint</code> 存在，反之不存在。</td>
</tr>
<tr>
<td><code>if linePoints_size ≥ n ?</code></td>
<td><code>linePoints</code>中的<code>binPoint</code>数量大于<code>n</code>表示满足判断条件。</td>
</tr>
</tbody></table>
<ul>
<li><strong>if curBinPoint valid ?</strong></li>
</ul>
<p>对应上述伪代码为第15行：</p>
<p><img src="/MD_IMG/2023-06-23-segmentation-01.assets/image-20230624200223441.png" alt="image-20230624200223441"></p>
<p>源代码为（linefit_ground_segmentation&#x2F;src&#x2F;segment.cc: Line 69）：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Not enough points. // Add point if valid.</span></span><br><span class="line"><span class="keyword">if</span> (cur_point.d - current_line_points.<span class="built_in">back</span>().d &lt; long_threshold_ &amp;&amp;</span><br><span class="line">    std::<span class="built_in">fabs</span>(current_line_points.<span class="built_in">back</span>().z - cur_ground_height) &lt; max_start_height_) &#123;</span><br><span class="line">    current_line_points.<span class="built_in">push_back</span>(cur_point);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有两个条件需要同时满足（用本文中定义的符号描述，<code>cur_point</code>即本文的<code>curBinPoint</code>，<code>current_line_points</code>即本文的<code>linePoints</code>，<code>current_line_points.back()</code>即本文的<code>lastBinPoint</code>），</p>
<p>① <code>curBinPoint.d - lastBinPoint.d &lt; long_threshold</code>，当前点和上一个入选<code>linePoints</code>的<code>binPoint</code>的平面距离<code>delta_d</code>小于预设值，此处原作者选取的阈值为 1.0 米；</p>
<p>② <code>lastBinPoint.height_from_ground &lt; max_start_height</code>，上一个备选<code>binPoint</code>的距地面高度小于预设值，此处原作者选取的阈值为 0.1 米；</p>
<ul>
<li><strong>if localLine good ?</strong></li>
</ul>
<p>对应上述伪代码为第6行：</p>
<p><img src="/MD_IMG/2023-06-23-segmentation-01.assets/image-20230624201240126.png" alt="image-20230624201240126"></p>
<p>源代码为（linefit_ground_segmentation&#x2F;src&#x2F;segment.cc: Line 47）：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (error &gt; max_error_ ||</span><br><span class="line">    std::<span class="built_in">fabs</span>(cur_line.first) &gt; max_slope_ ||</span><br><span class="line">    (current_line_points.<span class="built_in">size</span>() &gt; <span class="number">2</span> &amp;&amp; std::<span class="built_in">fabs</span>(cur_line.first) &lt; min_slope_) ||</span><br><span class="line">    is_long_line &amp;&amp; std::<span class="built_in">fabs</span>(expected_z - cur_point.z) &gt; max_long_height_) &#123;</span><br><span class="line">    current_line_points.<span class="built_in">pop_back</span>();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>源码中:</p>
<ul>
<li><p><code>error</code>：即<code>fiterror</code>，计算<code>linePoints</code>中所有点到拟合直线的距离并取其最大距离作为此拟合误差值；</p>
</li>
<li><p><code>cur_line.first</code>：拟合直线的斜率，也即拟合的地面坡度；</p>
</li>
<li><p><code>is_long_line</code>：<code>curBinPoint.d - lastBinPoint.d &gt; long_threshold</code>，当前点和上一个备选<code>binPoint</code>的平面距离大于预设值，则<code>is_long_line</code>为<code>true</code>；</p>
</li>
<li><p><code>expected_z</code>：当前点在上一个拟合地面线上的Z值</p>
</li>
</ul>
<p>以下四个条件满足任意一个，即表示刚刚拟合的地面线不是一个“好的直线”：</p>
<ul>
<li><p>① 拟合误差<code>error</code>大于设定阈值；</p>
</li>
<li><p>② 拟合的地面坡度<code>cur_line.first</code>大于设定阈值；</p>
</li>
<li><p>③ 拟合点数量<code>linePoints_size ≥3</code> 且 拟合的地面坡度<code>cur_line.first</code>大于设定阈值；</p>
</li>
<li><p>④ 同时满足<code>curBinPoint.d-lastBinPoint.d&gt;long_threshold</code>，<br>和<code>abs(expected_z-cur_point.z)&gt;max_long_height</code> 两个阈值条件。</p>
</li>
</ul>
<h2 id="4-地面点云分割"><a href="#4-地面点云分割" class="headerlink" title="4 地面点云分割"></a>4 地面点云分割</h2><p>简单来讲，就是计算激光点到当前及相邻的Segment中的拟合地面线段的投影误差，如果小于设置阈值，则认为是地面点，否则为非地面点。</p>
<p>此处关键在于找到正确的对应地面线段，要求激光点 $P(r,z)$ 的 $r$ 值在地面线段的起止点区间内 $(r_{min},r_{max})$ 方可认为是对应的地面线段，为了更有效地进行匹配，算法的匹配过程给这个起止区间加上了一个余量（或称为缓冲）<code>kMargin</code>，实际满足的条件为 $r\in(r_{min}-kMargin,\ \ r_{max}+kMargin)$。</p>
<p>具体步骤如下：</p>
<ul>
<li>① 在激光点所在的segment内，匹配地面线段，若匹配到合适的地面线段，则计算投影误差并返回；</li>
<li>② 若在①中没有成功匹配地面线段，则在邻域segment内，重复①步骤。其中，邻域segment定义为角度相差小于阈值<code>line_search_angle</code> 的左右相邻segment；</li>
<li>③ 无法匹配地面线段的激光点为非地面点；</li>
<li>④ 已经匹配地面线段的激光点，投影误差小于阈值 <code>max_dist_to_line</code> 的激光点为地面点，否则为非地面点。</li>
</ul>
<h2 id="5-算法参数设置"><a href="#5-算法参数设置" class="headerlink" title="5 算法参数设置"></a>5 算法参数设置</h2><p>前文中涉及到了不少的参数设置，主要是相关阈值，在这里总结一下。</p>
<p>在源代码中，参数配置文件为 linefit_ground_segmentation_ros&#x2F;launch&#x2F;segmentation_params.yaml</p>
<p>有以下参数：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">n_threads:</span> <span class="number">4</span>                <span class="comment"># number of threads to use.</span></span><br><span class="line"></span><br><span class="line"><span class="attr">r_min:</span> <span class="number">0.5</span>                  <span class="comment"># minimum point distance.</span></span><br><span class="line"><span class="attr">r_max:</span> <span class="number">50</span>                   <span class="comment"># maximum point distance.</span></span><br><span class="line"><span class="attr">n_bins:</span> <span class="number">120</span>                 <span class="comment"># number of radial bins.</span></span><br><span class="line"><span class="attr">n_segments:</span> <span class="number">360</span>             <span class="comment"># number of radial segments.</span></span><br><span class="line">     </span><br><span class="line"><span class="attr">max_dist_to_line:</span> <span class="number">0.05</span>      <span class="comment"># maximum vertical distance of </span></span><br><span class="line">                            <span class="comment"># point to line to be considered ground.</span></span><br><span class="line"></span><br><span class="line"><span class="attr">sensor_height:</span> <span class="number">1.8</span>          <span class="comment"># sensor height above ground.</span></span><br><span class="line"><span class="attr">min_slope:</span> <span class="number">0.0</span>              <span class="comment"># minimum slope of a ground line.</span></span><br><span class="line"><span class="attr">max_slope:</span> <span class="number">0.3</span>              <span class="comment"># maximum slope of a ground line.</span></span><br><span class="line"><span class="attr">max_fit_error:</span> <span class="number">0.05</span>         <span class="comment"># maximum error of a point during line fit.</span></span><br><span class="line"><span class="attr">long_threshold:</span> <span class="number">1.0</span>         <span class="comment"># distance between points after which </span></span><br><span class="line">                            <span class="comment"># they are considered far from each other.</span></span><br><span class="line"><span class="attr">max_long_height:</span> <span class="number">0.1</span>        <span class="comment"># maximum height change to previous point in long line.</span></span><br><span class="line"><span class="attr">max_start_height:</span> <span class="number">0.2</span>       <span class="comment"># maximum difference to estimated </span></span><br><span class="line">                            <span class="comment"># ground height to start a new line.</span></span><br><span class="line"><span class="attr">line_search_angle:</span> <span class="number">0.1</span>      <span class="comment"># how far to search in angular direction </span></span><br><span class="line">                            <span class="comment"># to find a line [unit: rad].</span></span><br><span class="line"></span><br><span class="line"><span class="attr">gravity_aligned_frame:</span> <span class="string">&quot;&quot;</span>   <span class="comment"># Frame which has its z axis aligned with gravity. </span></span><br><span class="line">                            <span class="comment"># (Sensor frame if empty.)</span></span><br><span class="line"></span><br><span class="line"><span class="attr">latch:</span> <span class="literal">false</span>                <span class="comment"># latch output topics or not</span></span><br><span class="line"><span class="attr">visualize:</span> <span class="literal">false</span>            <span class="comment"># visualize segmentation result - USE ONLY FOR DEBUGGING</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="6-效果展示"><a href="#6-效果展示" class="headerlink" title="6 效果展示"></a>6 效果展示</h2><p>论文中的效果展示：</p>
<p><img src="/MD_IMG/2023-06-23-segmentation-01.assets/image-20230701232839694.png" alt="image-20230701232839694"></p>
<h2 id="7-其他"><a href="#7-其他" class="headerlink" title="7 其他"></a>7 其他</h2><p>博文 <a href="https://blog.csdn.net/lovelyaiq/article/details/118826534">地面分割：Fast Segmentation of 3D Point Clouds for Ground Vehicles_TiRan_Yang的博客</a> 中举了一个实例，对代码进行了解读，可参看。</p>
]]></content>
      <categories>
        <category>激光雷达</category>
        <category>lidar算法</category>
        <category>地面分割</category>
      </categories>
      <tags>
        <tag>lidar</tag>
        <tag>地面分割</tag>
        <tag>segmentation</tag>
      </tags>
  </entry>
  <entry>
    <title>地面分割算法（二）：Ground_removal in LeGO-LOAM</title>
    <url>/2023/06/30/2023-06-30-segmentation-02/</url>
    <content><![CDATA[<p>paper: <a href="https://ieeexplore.ieee.org/abstract/document/8594299">LeGO-LOAM: Lightweight and Ground-Optimized Lidar Odometry and Mapping on Variable Terrain</a></p>
<p>Github: <a href="https://github.com/RobustFieldAutonomyLab/LeGO-LOAM">LeGO-LOAM - (RobustFieldAutonomyLab)</a></p>
<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h2><p>在LeGO-LOAM中，Ground removal 部分引用了上文 <a href="https://miaomiao-w.github.io/posts/segmentation-01/">地面分割算法（一）：linefit_ground_segmentation</a> 中介绍的论文 <a href="https://ieeexplore.ieee.org/document/5548059/figures#figures">Fast segmentation of 3D point clouds for ground vehicles</a>，但只是用了其中考虑地面坡度的思想，具体的代码实现有非常大的区别，包括点云的结构化方式和具体的地面滤除实施，并且代码非常的简化精炼。</p>
<p>Ground removal 部分的核心代码位于 LeGO-LOAM\LeGO-LOAM\src\imageProjection.cpp 文件中。 主要有两部分：点云结构化 <code>projectPointCloud()</code> 和地面滤除 <code>groundRemoval()</code>。</p>
<h2 id="2-点云结构化"><a href="#2-点云结构化" class="headerlink" title="2 点云结构化"></a>2 点云结构化</h2><ul>
<li><strong>主要原理</strong></li>
</ul>
<p>根据每个点的水平角度和垂直角度，再预先设置两个方向的角度分辨率，可计算得到每个点在这两个方向上的索引，将点云重新映射为基于图像的组织方式。</p>
<p>核心代码所在：<code>LeGO-LOAM\LeGO-LOAM\src\imageProjection.cpp\projectPointCloud()</code></p>
<ul>
<li><strong>角度分辨率的设置</strong></li>
</ul>
<p>可以参考激光雷达设备手册上的参数，一般都有关于激光点云在水平和垂直两个方向上的角度分辨率，可直接将其作为我们需要的阈值，这样可以最大程度保证每个点都能有效利用。事实上，也可以通过这两个阈值的设置（给定一个更大的值，如2倍于设备本身的角度分辨率），在点云映射的同时达到降采样的目的，这个可以根据实际需求。</p>
<p>源码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// location: LeGO-LOAM\LeGO-LOAM\include\utility.h</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">float</span> ang_res_x = <span class="number">0.2</span>; <span class="comment">// degree</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">float</span> ang_res_y = <span class="number">2.0</span>;</span><br></pre></td></tr></table></figure>



<ul>
<li><strong>计算水平角和垂直角</strong></li>
</ul>
<p>直接基于点坐标计算即可。垂直角$\theta_{v}$ ，水平角$\theta_{h}$ 。<br>$$<br>{\theta_{v}}<em>i&#x3D;\arctan{(\frac{z_i}{\sqrt{x_i^2+y_i^2}})} \\<br>{\theta</em>{h}}_i&#x3D;\arctan{(\frac{x_i}{y_i})}<br>$$<br>注：以上水平角公式是LeGO-LOAM中的计算方法，这个与坐标系定义和水平角起始方向选取有关。这里是以激光雷达坐标系的y轴正方向为0。这里用 $\arctan{(\frac{x_i}{y_i})}$ 还是 $\arctan{(\frac{y_i}{x_i})}$ 来计算依据实际需求而定。</p>
<p>源码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// location: LeGO-LOAM\LeGO-LOAM\src\imageProjection.cpp\projectPointCloud()</span></span><br><span class="line"><span class="type">float</span> distance = <span class="built_in">sqrt</span>(thisPoint.x * thisPoint.x + thisPoint.y * thisPoint.y);</span><br><span class="line">verticalAngle = <span class="built_in">atan2</span>(thisPoint.z, distance) * <span class="number">180</span> / M_PI;</span><br><span class="line">horizonAngle = <span class="built_in">atan2</span>(thisPoint.x, thisPoint.y) * <span class="number">180</span> / M_PI;</span><br></pre></td></tr></table></figure>




<ul>
<li><strong>计算激光点在图像上的坐标</strong></li>
</ul>
<p>这个坐标也就是上述【主要原理】中所讲的索引值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// location: LeGO-LOAM\LeGO-LOAM\src\imageProjection.cpp\projectPointCloud()</span></span><br><span class="line">rowIdn = (verticalAngle + ang_bottom) / ang_res_y;</span><br><span class="line">columnIdn = -<span class="built_in">round</span>((horizonAngle<span class="number">-90.0</span>)/ang_res_x) + Horizon_SCAN/<span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>这里的 <code>ang_bottom</code> 的引入和<code>-90.0</code>、<code>+ Horizon_SCAN/2</code> 都是为了将索引值转化为大于等于0的正整数，以符合图像中坐标的定义，也正是其所谓索引。</p>
<p>特别地，如果是机械雷达，<code>rowIdn</code> 其实就是 <code>ring</code>，可以免去这部分的计算，直接将 <code>ring</code> 值赋给 <code>rowIdn</code> 即可。</p>
<ul>
<li><strong>举例说明</strong></li>
</ul>
<p>以机械雷达为例：</p>
<p>图像行：每一线激光点就是图像中的一行点，并且图像中的任意一行的首尾其实也是相邻的，这点在后续的点云聚类中有体现（不在此文的地面点云分割范围）；</p>
<p>图像列：下图中两圈表示机械雷达的两线点云，红框中是同一个方向的分属于两线的两个点，映射到图像中就是同一列中相邻的两个像素点。</p>
<p><img src="/MD_IMG/2023-06-30-segmentation-02.assets/image-20230701184940252.png" alt="image-20230701184940252"></p>
<h2 id="3-地面滤除"><a href="#3-地面滤除" class="headerlink" title="3 地面滤除"></a>3 地面滤除</h2><p>LeGO-LOAM中地面滤除算法非常简单。</p>
<p>从靠近激光雷达的点开始判断。对于任意当前一点，再取出下一点（下一行中同一列的激光点），计算这两个点形成的坡度大小，再依据给定的坡度阈值（文中取值为10度），判断其是否为地面点。</p>
<p>激光点是有可能有无效点的，没有收到回波的点一般存为Nan点，那么如果当前或者下一点是无效点，这个坡度值就没办法计算了，那么当前点就标记为 -1；</p>
<p>对于正常的两个点，如果计算坡度小于阈值，则两点同为地面点，标记为 1；</p>
<p>如果计算坡度大于阈值，则两点均为非地面点，标记为 0。</p>
<p>结束了，就这么简单。</p>
<p>可能会有人要问了，那如果是一个障碍物目标，它的上表面比较平整，不是就被误判为地面点了吗？</p>
<p>是这样，肯定是有这个的概率的。但是本文的地面分割是为了更好地做后续的特征匹配的工作，这里不是为了做障碍物识别，所以这一点误判影响并不大；并且，这些误判点不一定会被识别为特征点，可以说又降低了其影响；再者，论文中的实验大多是周围是植被的环境，且安装位置也比较低，不太容易出现上面所说的这种情况。</p>
<p>所以要注意，如果是用于自动驾驶的避障中，可能要多关注这个问题。特别是安装在巴士顶部的激光雷达，能够看到前车的顶部，特别是挂车后的拖挂平板这种，可能就漏掉了。这是需要注意的。</p>
<h2 id="4-点云的代码结构"><a href="#4-点云的代码结构" class="headerlink" title="4 点云的代码结构"></a>4 点云的代码结构</h2><p>这部分的代码组织个人感觉还是很好的，可以借鉴参考。</p>
<p>首先根据两个方向的视场角和角度分辨率，可以得到图像的大小。这个size一般事先计算当做参数输入。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// location: LeGO-LOAM\LeGO-LOAM\include\utility.h</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">int</span> N_SCAN = <span class="number">16</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">int</span> Horizon_SCAN = <span class="number">1800</span>;</span><br></pre></td></tr></table></figure>

<p>这里用了三个变量来存储结构化的点云，rangeMat，groundMat，fullCloud</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cv::Mat rangeMat; <span class="comment">// range matrix for range image</span></span><br><span class="line">cv::Mat groundMat; <span class="comment">// ground matrix for ground cloud marking</span></span><br><span class="line">rangeMat  = cv::<span class="built_in">Mat</span>(N_SCAN, Horizon_SCAN, CV_32F, cv::Scalar::<span class="built_in">all</span>(FLT_MAX));</span><br><span class="line">groundMat = cv::<span class="built_in">Mat</span>(N_SCAN, Horizon_SCAN, CV_8S, cv::Scalar::<span class="built_in">all</span>(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// projected velodyne raw cloud, but saved in the form of 1-D matrix</span></span><br><span class="line">pcl::PointCloud&lt;PointType&gt;::Ptr fullCloud; </span><br><span class="line">fullCloud-&gt;points.<span class="built_in">resize</span>(N_SCAN*Horizon_SCAN);</span><br><span class="line">std::<span class="built_in">fill</span>(fullCloud-&gt;points.<span class="built_in">begin</span>(), fullCloud-&gt;points.<span class="built_in">end</span>(), nanPoint);</span><br></pre></td></tr></table></figure>

<p><code>rangeMat、groundMat</code> 为图像形式，分别存储距离值和是否地面点的标签。<code>fullCloud</code> 为 <code>pcl</code> 的点云格式，并且与图像格式一一对应，<code>fullCloud</code> 中 <code>index</code> 为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// rowIdn       : point index of image row</span></span><br><span class="line"><span class="comment">/// columnIdn    : point index of image column</span></span><br><span class="line"><span class="comment">/// Horizon_SCAN : size of each image row</span></span><br><span class="line">index = columnIdn  + rowIdn * Horizon_SCAN;</span><br></pre></td></tr></table></figure>

<p>如此对应，便于点云组织以及后续算法调用。</p>
<p>以下是论文中特征提取的过程。</p>
<p><img src="/MD_IMG/2023-06-30-segmentation-02.assets/image-20230701232141293.png" alt="image-20230701232141293"></p>
]]></content>
      <categories>
        <category>激光雷达</category>
        <category>lidar算法</category>
        <category>地面分割</category>
      </categories>
      <tags>
        <tag>lidar</tag>
        <tag>地面分割</tag>
        <tag>segmentation</tag>
      </tags>
  </entry>
  <entry>
    <title>LIOSAM 工程是怎么跑起来的</title>
    <url>/2023/07/06/2023-07-06-liosam-mapOpt-01/</url>
    <content><![CDATA[<p>liosam 工程是怎么跑起来的</p>
<p>LIOSAM 的中 Topic 与 node 的关联图，咋一看非常之多，十分骇人，但是从捋出重要 Topic 之后，就简练的多了，关注以下这些：</p>
<p>&#x2F;lio_sam&#x2F;mapping&#x2F;odometry_incremental：节点 </p>
<p>rosgraph-more-topics</p>
<p>rosgraph-less-topics</p>
<h2 id="后端优化中雷达位姿的初值获取"><a href="#后端优化中雷达位姿的初值获取" class="headerlink" title="后端优化中雷达位姿的初值获取"></a>后端优化中雷达位姿的初值获取</h2><p>LIOSAM 中的 lidar_link 其实也就是base_link，它与机器人场景中的机器人、自动驾驶场景的车辆是类似的。</p>
<p>在优化问题中，一个好的初值是非常重要的。LIOSAM在启动过程中，不同的状态下位姿初值获取选用了不同的方案。</p>
<h3 id="第一帧"><a href="#第一帧" class="headerlink" title="第一帧"></a>第一帧</h3><p>当接收到第一帧点云，将IMU原始数据中的角度值作为初始姿态，位置直接用（0，0，0）。位姿初始化在文件 <code>mapOptmization.cpp</code> 中， ， 代码如下，</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//// @file： LIO-SAM/src/mapOptmization.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">updateInitialGuess</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// save current transformation before any processing</span></span><br><span class="line">    incrementalOdometryAffineFront = <span class="built_in">trans2Affine3f</span>(transformTobeMapped);</span><br><span class="line">    <span class="type">static</span> Eigen::Affine3f lastImuTransformation;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// initialization</span></span><br><span class="line">    <span class="keyword">if</span> (cloudKeyPoses3D-&gt;points.<span class="built_in">empty</span>())<span class="comment">// lidar trajectory</span></span><br><span class="line">    &#123;</span><br><span class="line">        transformTobeMapped[<span class="number">0</span>] = cloudInfo.imuRollInit;<span class="comment">// 时间早于 point_cloud, 且最接近一帧的 imu 数据中的RPY</span></span><br><span class="line">        transformTobeMapped[<span class="number">1</span>] = cloudInfo.imuPitchInit;</span><br><span class="line">        transformTobeMapped[<span class="number">2</span>] = cloudInfo.imuYawInit;</span><br><span class="line">        <span class="keyword">if</span> (!useImuHeadingInitialization)</span><br><span class="line">            transformTobeMapped[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        lastImuTransformation = pcl::<span class="built_in">getTransformation</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, cloudInfo.imuRollInit, cloudInfo.imuPitchInit, cloudInfo.imuYawInit); <span class="comment">// save imu before return;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// use imu pre-integration estimation for pose guess</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// use imu incremental estimation for pose guess (only rotation)</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述 updateInitialGuess() 函数中：</p>
<p>位姿保存在变量 transformTobeMapped[] 中，且只对角度赋值，位置值保留变量的初始化值；代码如下；</p>
<p>角度的赋初值：cloudInfo.imuRollInit &#x2F; imuPitchInit &#x2F; imuYawInit 的获取在文件 imageProjection.cpp 中，存于消息 cloud_info 中与其他消息一并发布；代码如下；</p>
<p>另还有两个参数 incrementalOdometryAffineFront 和 lastImuTransformation，lastImuTransformation 用于下一帧的雷达初始化（详见下一小节）；incrementalOdometryAffineFront在后续生成平滑的 lidar Odometry 中有应用。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//// @file： LIO-SAM/src/mapOptmization.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">allocateMemory</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; ++i)&#123;</span><br><span class="line">        transformTobeMapped[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//// @file： LIO-SAM/src/imageProjection.cpp    </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">imuDeskewInfo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...        </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="type">int</span>)imuQueue.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        sensor_msgs::Imu thisImuMsg = imuQueue[i];</span><br><span class="line">        <span class="type">double</span> currentImuTime = thisImuMsg.header.stamp.<span class="built_in">toSec</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// get roll, pitch, and yaw estimation for this scan</span></span><br><span class="line">        <span class="comment">// 持续更新 rpy 直到 IMU 时间为小于雷达时间且相距最近</span></span><br><span class="line">        <span class="keyword">if</span> (currentImuTime &lt;= timeScanCur)</span><br><span class="line">            <span class="built_in">imuRPY2rosRPY</span>(&amp;thisImuMsg, &amp;cloudInfo.imuRollInit, &amp;cloudInfo.imuPitchInit, &amp;cloudInfo.imuYawInit);</span><br><span class="line">        <span class="keyword">if</span> (currentImuTime &gt; timeScanEnd + <span class="number">0.05</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上述 imuDeskewInfo() 中的 imuRPY2rosRPY() 函数（line 23）定义在 utility.h 中，函数功能简单，只将 IMU_raw 中的 orientation 作格式转换，不多赘述。</p>
<h3 id="第二帧"><a href="#第二帧" class="headerlink" title="第二帧"></a>第二帧</h3><p>收到第二帧点云后，判断其不满足时间间隔阈值，直接返回。</p>
<h3 id="第三帧"><a href="#第三帧" class="headerlink" title="第三帧"></a>第三帧</h3><p>收到点云后，进入函数 updateInitialGuess() 中，不是第一帧后只需要关注后面的两个判断条件，<code>cloudInfo.imuAvailable, cloudInfo.odomAvailable</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//// @file： LIO-SAM/src/mapOptmization.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">updateInitialGuess</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// save current transformation before any processing</span></span><br><span class="line">    incrementalOdometryAffineFront = <span class="built_in">trans2Affine3f</span>(transformTobeMapped);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// initialization</span></span><br><span class="line">    <span class="keyword">if</span> (cloudKeyPoses3D-&gt;points.<span class="built_in">empty</span>())&#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// use imu pre-integration estimation for pose guess</span></span><br><span class="line">    <span class="keyword">if</span> (cloudInfo.odomAvailable == <span class="literal">true</span>)&#123;...&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// use imu incremental estimation for pose guess (only rotation)</span></span><br><span class="line">    <span class="keyword">if</span> (cloudInfo.imuAvailable == <span class="literal">true</span>)&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>imuAvailable,odomAvailable </code> 这两个参数同样来自于文件 <code>imageProjection.cpp  </code>  ：</p>
<ul>
<li><p>参数 <code>cloudInfo.imuAvailable</code> 是指是否收到用于畸变纠正的 <code>IMU</code> 原始数据，是一开始就有的；</p>
</li>
<li><p>参数 <code>cloudInfo.odomAvailable</code> 是指是否收到用于畸变纠正的 <code>IMU odometry</code> ，而这个 Topic 是在收到节点 <code>mapOptmization</code> 发出的 <code>lidar odometry</code> 后再下一帧处理所得（收到第一帧需要初始化）；</p>
</li>
</ul>
<p>因此进入第三个case，<code>if (cloudInfo.imuAvailable == true)&#123;...&#125;</code> 。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//// @file： LIO-SAM/src/mapOptmization.cpp</span></span><br><span class="line"><span class="type">void</span> updateInitialGue当前帧的位姿初值 `transFinal=transTobe * transIncre` <span class="built_in">ss</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// save current transformation before any processing</span></span><br><span class="line">    incrementalOdometryAffineFront = <span class="built_in">trans2Affine3f</span>(transformTobeMapped);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// initialization</span></span><br><span class="line">    ...    </span><br><span class="line">    <span class="comment">// use imu pre-integration estimation for pose guess</span></span><br><span class="line">    ...    </span><br><span class="line">    <span class="comment">// use imu incremental estimation for pose guess (only rotation)</span></span><br><span class="line">    <span class="keyword">if</span> (cloudInfo.imuAvailable == <span class="literal">true</span>)&#123;        </span><br><span class="line">        <span class="built_in">ROS_WARN</span>(<span class="string">&quot;Guess init, imuAvailable&quot;</span>);</span><br><span class="line">        Eigen::Affine3f transBack = pcl::<span class="built_in">getTransformation</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, cloudInfo.imuRollInit, cloudInfo.imuPitchInit, cloudInfo.imuYawInit);</span><br><span class="line">        Eigen::Affine3f transIncre = lastImuTransformation.<span class="built_in">inverse</span>() * transBack;</span><br><span class="line"></span><br><span class="line">        Eigen::Affine3f transTobe = <span class="built_in">trans2Affine3f</span>(transformTobeMapped);</span><br><span class="line">        Eigen::Affine3f transFinal = transTobe * transIncre;</span><br><span class="line">        pcl::<span class="built_in">getTranslationAndEulerAngles</span>(transFinal, transformTobeMapped[<span class="number">3</span>], transformTobeMapped[<span class="number">4</span>], transformTobeMapped[<span class="number">5</span>], </span><br><span class="line">                                                      transformTobeMapped[<span class="number">0</span>], transformTobeMapped[<span class="number">1</span>], transformTobeMapped[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">        lastImuTransformation = pcl::<span class="built_in">getTransformation</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, cloudInfo.imuRollInit, cloudInfo.imuPitchInit, cloudInfo.imuYawInit); <span class="comment">// save imu before return;</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这一段代码的逻辑是，通过结合上一帧的雷达位姿和两帧雷达位姿的增量来计算而得，获取当前帧的雷达位姿。</p>
<p>上一帧的雷达位姿初值 $T_{last_init}$ ：上一帧处理过程中存于变量 <code>lastImuTransformation</code> ；</p>
<p>上一帧雷达位姿优化值 $T_{last_opt}$ ：上一帧的优化位姿，存于 <code>transformTobeMapped[]</code> ，格式转换得到 <code>transTobe</code> ；</p>
<p>当前帧雷达位姿临时值 $T_{cur_temp}$ ：当前帧从 <code>IMU</code>原始数据中获取的位姿，存于 <code>transBack</code> ；</p>
<p>当前帧的雷达位姿初值 $T_{cur_init}$ ：也就是当前函数的待求值，前帧的位姿初值 <code>transFinal=transTobe * transIncre</code> &gt;。</p>
<p>两帧之间的位姿增量 $T_{between}$ ：上一帧位姿初值 $T_{last-init}$ 和当前帧雷达位姿临时值 $T_{cur_temp}$ 之间的增量（<code>transIncre</code>）；</p>
<p>用公式表示为：<br>$$<br>T_{between}&#x3D;T_{last_init}^{-1}T_{cur_temp}\T_{cur_init}&#x3D;T_{last_opt}T_{between}<br>$$<br>得到当前帧位姿初值后，再度存于 <code>transformTobeMapped[]</code> 中对其进行更新，这个参数非常重要的。</p>
<p>并同时更新<code>lastImuTransformation</code> 用于下一帧的处理。</p>
<p>注1：前面的【当前帧雷达位姿临时值】是笔者自己起的一个名字，为区别于用于后端优化的初值，而用了临时值的说法。</p>
<p>注2：这部分应用到有关矩阵右乘的知识点，主要多加注意，可参考这个问题 <a href="https://www.zhihu.com/question/263660493">矩阵左乘，右乘到底是什么意思？</a>中 <a href="https://www.zhihu.com/people/yan-fei-can-yue-tian-50">糖糖不是堂</a> 的回答。</p>
<h3 id="第四帧"><a href="#第四帧" class="headerlink" title="第四帧"></a>第四帧</h3><p>同第二帧情形，不满足时间间隔阈值，直接返回。</p>
<h3 id="第五帧"><a href="#第五帧" class="headerlink" title="第五帧"></a>第五帧</h3><p>到此时，</p>
<h2 id="雷达里程计的最高频率"><a href="#雷达里程计的最高频率" class="headerlink" title="雷达里程计的最高频率"></a>雷达里程计的最高频率</h2><p>雷达里程计并不是对每一帧点云都进行处理，这里有一个时间阈值的判断。</p>
<p><a href="">《后端优化中 雷达 位姿的初始化》</a>中所说的第二帧，是指满足时间间隔要求的第二帧，实为第三帧，收到的第二帧点云与第一帧</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//// @file： LIO-SAM/src/mapOptmization.cpp</span></span><br><span class="line"><span class="keyword">if</span> (timeLaserInfoCur - timeLastProcessing &gt;= mappingProcessInterval)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>mappingProcessInterval</code>的默认参数是0.15s，所以在默认参数下，雷达里程计不会超过1&#x2F;0.15Hz</p>
<p>参数配置文件： <code>LIO-SAM/config/params.yaml</code></p>
<h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><ul>
<li><p>每个 Topic 具体发布的数据什么含义</p>
</li>
<li><p>mapOpt 中的lio_sam&#x2F;mapping&#x2F;odometry 与 lio_sam&#x2F;mapping&#x2F;odometry_incremental有什么区别与联系?</p>
</li>
</ul>
<p><a href="https://github.com/TixiaoShan/LIO-SAM/issues/92">https://github.com/TixiaoShan/LIO-SAM/issues/92</a></p>
<ul>
<li><p>odometry&#x2F;imu 与 odometry&#x2F;imu_incremental</p>
<p>odometry&#x2F;imu_incremental，在imagerojection发布</p>
<p>odometry&#x2F;imu，在transformusion中，</p>
</li>
<li><p>transformTobeMapped 的初始化与优化历程</p>
</li>
<li><p>gtsam 中 的先验因子和 Values 有什么区别</p>
</li>
<li><p>imgProject 中用于畸变纠正的 IMU 数据 Odom 数据</p>
<p>Odom 数据 为什么用 IMU 里程计，而不用 lidar Odom？因为后者滞后</p>
<p>roll，pitch，yaw 的纠正为什么用原始IMU，而不用  IMU 里程计 中的orientation？ 尚不清楚。</p>
</li>
<li><p>addOdomFactor() 为何首帧的噪声模型参数的yaw为 PI*PI？</p>
</li>
</ul>
]]></content>
      <categories>
        <category>SLAM</category>
        <category>LIOSAM</category>
      </categories>
      <tags>
        <tag>SLAM</tag>
        <tag>LIOSAM</tag>
        <tag>后端优化</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2023/07/09/liosam%20%E5%B7%A5%E7%A8%8B%E6%98%AF%E6%80%8E%E4%B9%88%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/</url>
    <content><![CDATA[<p>liosam 工程是怎么跑起来的</p>
<p>LIOSAM 的中 Topic 与 node 的关联图，咋一看非常之多，十分骇人，但是从捋出重要 Topic 之后，就简练的多了，关注以下这些：</p>
<p>&#x2F;lio_sam&#x2F;mapping&#x2F;odometry_incremental：节点 </p>
<p>rosgraph-more-topics</p>
<p>rosgraph-less-topics</p>
<h2 id="后端优化中雷达位姿的初值获取"><a href="#后端优化中雷达位姿的初值获取" class="headerlink" title="后端优化中雷达位姿的初值获取"></a>后端优化中雷达位姿的初值获取</h2><p>LIOSAM 中的 lidar_link 其实也就是base_link，它与机器人场景中的机器人、自动驾驶场景的车辆是类似的。</p>
<p>在优化问题中，一个好的初值是非常重要的。LIOSAM在启动过程中，不同的状态下位姿初值获取选用了不同的方案。</p>
<h3 id="第一帧"><a href="#第一帧" class="headerlink" title="第一帧"></a>第一帧</h3><p>当接收到第一帧点云，将IMU原始数据中的角度值作为初始姿态，位置直接用（0，0，0）。位姿初始化在文件 <code>mapOptmization.cpp</code> 中， ， 代码如下，</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//// @file： LIO-SAM/src/mapOptmization.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">updateInitialGuess</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// save current transformation before any processing</span></span><br><span class="line">    incrementalOdometryAffineFront = <span class="built_in">trans2Affine3f</span>(transformTobeMapped);</span><br><span class="line">    <span class="type">static</span> Eigen::Affine3f lastImuTransformation;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// initialization</span></span><br><span class="line">    <span class="keyword">if</span> (cloudKeyPoses3D-&gt;points.<span class="built_in">empty</span>())<span class="comment">// lidar trajectory</span></span><br><span class="line">    &#123;</span><br><span class="line">        transformTobeMapped[<span class="number">0</span>] = cloudInfo.imuRollInit;<span class="comment">// 时间早于 point_cloud, 且最接近一帧的 imu 数据中的RPY</span></span><br><span class="line">        transformTobeMapped[<span class="number">1</span>] = cloudInfo.imuPitchInit;</span><br><span class="line">        transformTobeMapped[<span class="number">2</span>] = cloudInfo.imuYawInit;</span><br><span class="line">        <span class="keyword">if</span> (!useImuHeadingInitialization)</span><br><span class="line">            transformTobeMapped[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        lastImuTransformation = pcl::<span class="built_in">getTransformation</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, cloudInfo.imuRollInit, cloudInfo.imuPitchInit, cloudInfo.imuYawInit); <span class="comment">// save imu before return;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// use imu pre-integration estimation for pose guess</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// use imu incremental estimation for pose guess (only rotation)</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述 updateInitialGuess() 函数中：</p>
<p>位姿保存在变量 transformTobeMapped[] 中，且只对角度赋值，位置值保留变量的初始化值；代码如下；</p>
<p>角度的赋初值：cloudInfo.imuRollInit &#x2F; imuPitchInit &#x2F; imuYawInit 的获取在文件 imageProjection.cpp 中，存于消息 cloud_info 中与其他消息一并发布；代码如下；</p>
<p>另还有两个参数 incrementalOdometryAffineFront 和 lastImuTransformation，lastImuTransformation 用于下一帧的雷达初始化（详见下一小节）；incrementalOdometryAffineFront在后续生成平滑的 lidar Odometry 中有应用。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//// @file： LIO-SAM/src/mapOptmization.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">allocateMemory</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; ++i)&#123;</span><br><span class="line">        transformTobeMapped[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//// @file： LIO-SAM/src/imageProjection.cpp    </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">imuDeskewInfo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...        </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="type">int</span>)imuQueue.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        sensor_msgs::Imu thisImuMsg = imuQueue[i];</span><br><span class="line">        <span class="type">double</span> currentImuTime = thisImuMsg.header.stamp.<span class="built_in">toSec</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// get roll, pitch, and yaw estimation for this scan</span></span><br><span class="line">        <span class="comment">// 持续更新 rpy 直到 IMU 时间为小于雷达时间且相距最近</span></span><br><span class="line">        <span class="keyword">if</span> (currentImuTime &lt;= timeScanCur)</span><br><span class="line">            <span class="built_in">imuRPY2rosRPY</span>(&amp;thisImuMsg, &amp;cloudInfo.imuRollInit, &amp;cloudInfo.imuPitchInit, &amp;cloudInfo.imuYawInit);</span><br><span class="line">        <span class="keyword">if</span> (currentImuTime &gt; timeScanEnd + <span class="number">0.05</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上述 imuDeskewInfo() 中的 imuRPY2rosRPY() 函数（line 23）定义在 utility.h 中，函数功能简单，只将 IMU_raw 中的 orientation 作格式转换，不多赘述。</p>
<h3 id="第二帧"><a href="#第二帧" class="headerlink" title="第二帧"></a>第二帧</h3><p>收到第二帧点云后，判断其不满足时间间隔阈值，直接返回。</p>
<h3 id="第三帧"><a href="#第三帧" class="headerlink" title="第三帧"></a>第三帧</h3><p>收到点云后，进入函数 updateInitialGuess() 中，不是第一帧后只需要关注后面的两个判断条件，<code>cloudInfo.imuAvailable, cloudInfo.odomAvailable</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//// @file： LIO-SAM/src/mapOptmization.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">updateInitialGuess</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// save current transformation before any processing</span></span><br><span class="line">    incrementalOdometryAffineFront = <span class="built_in">trans2Affine3f</span>(transformTobeMapped);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// initialization</span></span><br><span class="line">    <span class="keyword">if</span> (cloudKeyPoses3D-&gt;points.<span class="built_in">empty</span>())&#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// use imu pre-integration estimation for pose guess</span></span><br><span class="line">    <span class="keyword">if</span> (cloudInfo.odomAvailable == <span class="literal">true</span>)&#123;...&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// use imu incremental estimation for pose guess (only rotation)</span></span><br><span class="line">    <span class="keyword">if</span> (cloudInfo.imuAvailable == <span class="literal">true</span>)&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>imuAvailable,odomAvailable </code> 这两个参数同样来自于文件 <code>imageProjection.cpp  </code>  ：</p>
<ul>
<li><p>参数 <code>cloudInfo.imuAvailable</code> 是指是否收到用于畸变纠正的 <code>IMU</code> 原始数据，是一开始就有的；</p>
</li>
<li><p>参数 <code>cloudInfo.odomAvailable</code> 是指是否收到用于畸变纠正的 <code>IMU odometry</code> ，而这个 Topic 是在收到节点 <code>mapOptmization</code> 发出的 <code>lidar odometry</code> 后再下一帧处理所得（收到第一帧需要初始化）；</p>
</li>
</ul>
<p>因此进入第三个case，<code>if (cloudInfo.imuAvailable == true)&#123;...&#125;</code> 。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//// @file： LIO-SAM/src/mapOptmization.cpp</span></span><br><span class="line"><span class="type">void</span> updateInitialGue当前帧的位姿初值 `transFinal=transTobe * transIncre` <span class="built_in">ss</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// save current transformation before any processing</span></span><br><span class="line">    incrementalOdometryAffineFront = <span class="built_in">trans2Affine3f</span>(transformTobeMapped);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// initialization</span></span><br><span class="line">    ...    </span><br><span class="line">    <span class="comment">// use imu pre-integration estimation for pose guess</span></span><br><span class="line">    ...    </span><br><span class="line">    <span class="comment">// use imu incremental estimation for pose guess (only rotation)</span></span><br><span class="line">    <span class="keyword">if</span> (cloudInfo.imuAvailable == <span class="literal">true</span>)&#123;        </span><br><span class="line">        <span class="built_in">ROS_WARN</span>(<span class="string">&quot;Guess init, imuAvailable&quot;</span>);</span><br><span class="line">        Eigen::Affine3f transBack = pcl::<span class="built_in">getTransformation</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, cloudInfo.imuRollInit, cloudInfo.imuPitchInit, cloudInfo.imuYawInit);</span><br><span class="line">        Eigen::Affine3f transIncre = lastImuTransformation.<span class="built_in">inverse</span>() * transBack;</span><br><span class="line"></span><br><span class="line">        Eigen::Affine3f transTobe = <span class="built_in">trans2Affine3f</span>(transformTobeMapped);</span><br><span class="line">        Eigen::Affine3f transFinal = transTobe * transIncre;</span><br><span class="line">        pcl::<span class="built_in">getTranslationAndEulerAngles</span>(transFinal, transformTobeMapped[<span class="number">3</span>], transformTobeMapped[<span class="number">4</span>], transformTobeMapped[<span class="number">5</span>], </span><br><span class="line">                                                      transformTobeMapped[<span class="number">0</span>], transformTobeMapped[<span class="number">1</span>], transformTobeMapped[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">        lastImuTransformation = pcl::<span class="built_in">getTransformation</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, cloudInfo.imuRollInit, cloudInfo.imuPitchInit, cloudInfo.imuYawInit); <span class="comment">// save imu before return;</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这一段代码的逻辑是，通过结合上一帧的雷达位姿和两帧雷达位姿的增量来计算而得，获取当前帧的雷达位姿。</p>
<p>上一帧的雷达位姿初值 $T_{last_init}$ ：上一帧处理过程中存于变量 <code>lastImuTransformation</code> ；</p>
<p>上一帧雷达位姿优化值 $T_{last_opt}$ ：上一帧的优化位姿，存于 <code>transformTobeMapped[]</code> ，格式转换得到 <code>transTobe</code> ；</p>
<p>当前帧雷达位姿临时值 $T_{cur_temp}$ ：当前帧从 <code>IMU</code>原始数据中获取的位姿，存于 <code>transBack</code> ；</p>
<p>当前帧的雷达位姿初值 $T_{cur_init}$ ：也就是当前函数的待求值，前帧的位姿初值 <code>transFinal=transTobe * transIncre</code> &gt;。</p>
<p>两帧之间的位姿增量 $T_{between}$ ：上一帧位姿初值 $T_{last-init}$ 和当前帧雷达位姿临时值 $T_{cur_temp}$ 之间的增量（<code>transIncre</code>）；</p>
<p>用公式表示为：<br>$$<br>T_{between}&#x3D;T_{last_init}^{-1}T_{cur_temp}\T_{cur_init}&#x3D;T_{last_opt}T_{between}<br>$$<br>得到当前帧位姿初值后，再度存于 <code>transformTobeMapped[]</code> 中对其进行更新，这个参数非常重要的。</p>
<p>并同时更新<code>lastImuTransformation</code> 用于下一帧的处理。</p>
<p>注1：前面的【当前帧雷达位姿临时值】是笔者自己起的一个名字，为区别于用于后端优化的初值，而用了临时值的说法。</p>
<p>注2：这部分应用到有关矩阵右乘的知识点，主要多加注意，可参考这个问题 <a href="https://www.zhihu.com/question/263660493">矩阵左乘，右乘到底是什么意思？</a>中 <a href="https://www.zhihu.com/people/yan-fei-can-yue-tian-50">糖糖不是堂</a> 的回答。</p>
<h3 id="第四帧"><a href="#第四帧" class="headerlink" title="第四帧"></a>第四帧</h3><p>同第二帧情形，不满足时间间隔阈值，直接返回。</p>
<h3 id="第五帧"><a href="#第五帧" class="headerlink" title="第五帧"></a>第五帧</h3><p>到此时，</p>
<h2 id="雷达里程计的最高频率"><a href="#雷达里程计的最高频率" class="headerlink" title="雷达里程计的最高频率"></a>雷达里程计的最高频率</h2><p>雷达里程计并不是对每一帧点云都进行处理，这里有一个时间阈值的判断。</p>
<p><a href="">《后端优化中 雷达 位姿的初始化》</a>中所说的第二帧，是指满足时间间隔要求的第二帧，实为第三帧，收到的第二帧点云与第一帧</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//// @file： LIO-SAM/src/mapOptmization.cpp</span></span><br><span class="line"><span class="keyword">if</span> (timeLaserInfoCur - timeLastProcessing &gt;= mappingProcessInterval)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>mappingProcessInterval</code>的默认参数是0.15s，所以在默认参数下，雷达里程计不会超过1&#x2F;0.15Hz</p>
<p>参数配置文件： <code>LIO-SAM/config/params.yaml</code></p>
<h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><ul>
<li><p>每个 Topic 具体发布的数据什么含义</p>
</li>
<li><p>mapOpt 中的lio_sam&#x2F;mapping&#x2F;odometry 与 lio_sam&#x2F;mapping&#x2F;odometry_incremental有什么区别与联系?</p>
</li>
</ul>
<p><a href="https://github.com/TixiaoShan/LIO-SAM/issues/92">https://github.com/TixiaoShan/LIO-SAM/issues/92</a></p>
<ul>
<li><p>odometry&#x2F;imu 与 odometry&#x2F;imu_incremental</p>
<p>odometry&#x2F;imu_incremental，在imagerojection发布</p>
<p>odometry&#x2F;imu，在transformusion中，</p>
</li>
<li><p>transformTobeMapped 的初始化与优化历程</p>
</li>
<li><p>gtsam 中 的先验因子和 Values 有什么区别</p>
</li>
<li><p>imgProject 中用于畸变纠正的 IMU 数据 Odom 数据</p>
<p>Odom 数据 为什么用 IMU 里程计，而不用 lidar Odom？因为后者滞后</p>
<p>roll，pitch，yaw 的纠正为什么用原始IMU，而不用  IMU 里程计 中的orientation？ 尚不清楚。</p>
</li>
<li><p>addOdomFactor() 为何首帧的噪声模型参数的yaw为 PI*PI？</p>
</li>
</ul>
]]></content>
  </entry>
</search>
