<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>TO DO LIST</title>
    <url>/2023/06/01/2000-01-01-to-do-list/</url>
    <content><![CDATA[<h2 id="to-do-list"><a href="#to-do-list" class="headerlink" title="to do list"></a>to do list</h2><p>欧拉角万向锁问题，欧拉角不适用于插值和迭代</p>
<p>奇异性，奇异矩阵</p>
<p>微分方程（李代数的引出中提及，此处尚未完全理解）</p>
<p>最小二乘</p>
<p>SLAM模型的引出</p>
<p>LIOSAM整个工程是怎么跑起来的</p>
<p>第一帧走了哪些流程，第二帧，第三帧呢</p>
]]></content>
  </entry>
  <entry>
    <title>话年事</title>
    <url>/2019/02/18/2019-02-18-guo-nian/</url>
    <content><![CDATA[<p><img src="/MD_IMG/2019-02-18-guo-nian.assets/image-20230716191505499.png"></p>
<p>上班了，这个年真正意义上过完了，趁机来唠叨几句。</p>
<p>过年过年，但是估摸着人们大概并没有细想过何为“过年”。最初对“过年”一词有想法，源于曾经很火的电视剧《春光灿烂猪八戒》里出现的“年兽”，而这年兽也有种说法是叫做“夕”。过年的众多习俗是为了安全的躲过年兽的攻击；而“除夕”也自然能自圆其说一点了。</p>
<p>纯属啰嗦几句，下面言归正传。</p>
<p><img src="/MD_IMG/2019-02-18-guo-nian.assets/image-20230716191554920.png" alt="image-20230716191554920"></p>
<p>最近几年过年回家都是腊月底，这回依旧是，到家已经是腊月二十九近傍晚时分。看见弟弟妹妹在贴春联，我放下行李，走到跟前，习惯性去帮忙。妹妹看到我来，如蒙大赦，终于有人接手，转身去到厨房忙别的去。她是真的不喜这个，我却乐得于此。</p>
<p>贴完对联，眼睛扫过左邻右舍大门后门上贴的对子，不难发现，现在大家伙的要求已经没有那么严格了，对仗似乎算不上工整，平仄韵脚也没那么讲究，上联在右或在左，横批左起还是右起，都已经不那么重要，要紧的是这一定是几句好话，图个新年的好彩头，它的目的和意义也就都有了。</p>
<p>按照家里习俗，每年应是除夕那天下午贴对联，今年怎么大年二十九就全部都弄好了，原来是年三十那天正好也是立春，“迎春”当天是不贴对联的，第一次知道竟还有这个讲究和说法。</p>
<p>今年的除夕，不仅立春节气，还来了一场当下罕见的太阳雨，今年整个假期唯一见到的几分钟的太阳。</p>
<p><img src="/MD_IMG/2019-02-18-guo-nian.assets/640.jpeg" alt="图片"></p>
<p>以前，更兴自家写对联。老爸写得一手毛笔字。</p>
<p>那会儿，总是在客厅摆上八仙桌，放好长凳，老爸拿出早已备好红纸笔墨，砚是没有的，比较简陋，直接把墨水倒在一个碗里就成，然后把红纸折出米字格，摊开，准备就绪，小小的我总是跪在老爸对面的长凳上，两手按住红纸，充当人工镇尺，专注地看着老爸把已经选好的对子呈现在米字格里。</p>
<p>家里是有好几本对联书的，现在已经不知道藏身何处了，不知是否还安好。</p>
<p>老爸经常在我们姊妹三个面前炫耀说，他那毛笔字可是没怎么练的，上手就这么写的，还能写小楷呢，我们自是不清楚，只得说厉害厉害。这话不是敷衍，家里只有老爸会，厉害是心悦诚服的厉害。</p>
<p>刚上大学时，我就兴冲冲报了个学校的书画社团，也想要学习学习，怎奈不会写怕闹笑话畏首畏尾，最终也没练成，毛笔毛毡墨水宣纸倒是买齐过，现在想想，若是坚持写下来，也是有十来年了，说不定还真就能写的不错了。</p>
<p>“做一件事情最好的时机是十年前，其次是现在。”不无道理。</p>
<p><img src="/MD_IMG/2019-02-18-guo-nian.assets/image-20230716191620933.png" alt="image-20230716191620933"></p>
<p>说到过年，家人团团圆圆必然是一大主题，而团圆自然是避不开“北方饺子和南方汤圆”。</p>
<p>在北京待的四五年，甚有体会，中秋吃饺子，冬至吃饺子，除夕吃饺子，元宵吃饺子，似乎是个节日都吃饺子，甚至于，根本不需要节日，也是要吃饺子的。</p>
<p>对于一个不会包饺子的蓝方人，速冻是首选，这其中最爱湾仔码头，确是前几天微信刷到其创始人“水饺皇后”臧建和去世的消息，禁不住几声唏嘘。</p>
<p>把这消息转到朋友圈，有同事说最爱的饺子标准答案应是妈妈包的饺子的味道，其实我想说，妈妈专属的温暖回忆属于汤圆。</p>
<p>南方，除夕元宵吃汤圆的多，汤圆的馅料多种多样，黑芝麻、紫薯、香芋、豆沙、花生、五仁等等，甜口偏多。这些是上大学之后，走出家门了才知道的，超市会告诉我们这些。</p>
<p>而作为一个土生土长的南方人，奉新人，在家里，只认肉馅儿的，也不是没吃过别的，现在什么没得卖啊，但是终究不是自己做出来的原来的那个味道。</p>
<p>为什么是肉馅儿？追究起来是有点历史原因的。小时候生活条件不好，肉自然是稀罕物。所以从小记忆中，肉馅的才是好的，不仅仅汤圆，粽子也是这样，红豆绿豆的就是不如肉馅的贵气，甚至平常做个饼也是肉馅儿饼才最好吃。</p>
<p>后来生活好点，就有一个习惯，做菜总喜欢放点肉，青菜萝卜里面也爱放，这不论好坏，算是个历史遗留产物。</p>
<p><img src="/MD_IMG/2019-02-18-guo-nian.assets/640-16895061936582.jpeg" alt="图片"></p>
<p>年三十这天下午，老妈喊我到厨房一起做汤圆，馅儿已经备好，揉好米团，最费时间就是一个一个包汤圆了，那边在锅里放好了水在烧着，这边我俩一个个的汤圆包着。</p>
<p>老妈说我包的比她的好，大小均匀也更圆乎，其实她那是着急总想着弄好了好早点开饭，我才没这个压力，只当是件事做着就行，后来老妹也加入战斗。</p>
<p>老妈手上忙着嘴里还念念有词，总是担心太少了，吃不饱，其实不然，虽然我们都已经长大了，但是已经不似以前那么能吃了。小时候反而能吃的更多，我们姐弟仨还经常比赛谁吃得更多，二十个是常有的事，现在估计只够得着一个零头了。</p>
<p>这边包好，那边水也烧好，就等着热气腾腾的成品上桌了。汤圆是主角，自然也少不了鸡鸭鱼肉时鲜蔬菜。</p>
<p>看着朋友圈很多晒着山珍海味满汉全席，大大的桌子，满满的佳肴，不过，简单的吃着汤圆，就着“年年有鱼”，也很满足。</p>
<hr>
<p>写完了才发现，都是老爸老妈给予的温暖小事，小事最是温情。</p>
<p> 今天的网易日推的压轴曲是《爱得太迟》，不喜欢“树欲静而风不止”的表述，用它来结尾。</p>
<hr>
<blockquote>
<p>日夜做 储的钱都应该够  到圣诞正好讲 跟我白头<br>谁知他开了口  未能挨下去 己恨我很久<br>错失太易 爱得太迟  我怎想到 她忍不到那日子<br>盲目地发奋 忙忙忙从来未知  幸福会掠过<br>再也没法说钟意  爱一个字 也需要及时<br>只差一秒 心声都己变历史  为何未放肆<br>见我爱见的相知  要抱要吻要怎么也好<br>不要相信一切有下次  相拥我所爱又花几多秒<br>这几秒 能够做到又有多少  未算少 足够遗憾忙掉<br>多少抱憾 多少过路人  太懂估计 却不懂爱惜自身<br>人人在发奋 想起他朝都兴奋  但今晚未过 你要过也很吸引<br>纵不信运 你不过是人  理想很远 爱于咫尺却在等<br>来日别操心 趁你有能力开心  世界有太多东西发生<br>不要等到天上俯瞰</p>
</blockquote>
]]></content>
      <categories>
        <category>随笔</category>
        <category>生活记</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>年年岁岁灯如旧</title>
    <url>/2019/02/24/2019-02-24-light/</url>
    <content><![CDATA[<p>常言道，“十五的月亮十六圆”，故宫博物院建院94年来首次举办“灯会”，即是在这两日–“紫禁城上元之夜”。用脚指头都能想到，必然是一票难求。</p>
<p>为此，特意设置闹钟提醒，提前几分钟守着抢票，果然，放票点未到，网站已经先崩了；不行，不能放弃，坚持刷一直刷，果然，登陆还未成功，票已售罄，手动[微笑脸]。嗯，还是坚持刷到登陆成功，看着余票0张，然后再满意地睡去。</p>
<p> 情理之中，意料之中，也没什么好遗憾的。</p>
<p> 那是因为已经买到了圆明园的门票了呀，哈哈哈~</p>
<p> “最是故园情浓浓家乡愁——圆明园元宵灯会”。</p>
<p><img src="/MD_IMG/2019-02-24-light.assets/640.jpeg"></p>
<p>下班后，刚上地铁，接到老弟打来的电话。我和老妹都回单位了，就他放假长还没滚回学校，这个点打电话来，肯定是来炫耀的。</p>
<p>果不其然，电话一接通，就开始兴奋地滔滔不绝，“大姐大姐，你猜我们在干啥？我和妈妈在煮汤圆哈哈哈。刚刚妈妈说，你小的时候，刚会走路不久，指着咱们’散灯’的蜡烛说’有’，然后又指着另一个说’有’，就只一个字……”</p>
<p>还特意把那个“有”字拖的老长老长。在他的开篇轰炸中，我只够说个“喂”“干啥”。</p>
<p>要不说“无巧不成书”呢，那会刚把这个“指烛道有”的小文发出，然后让他去给老爸老妈看。</p>
<p>后来老爸看完后评论说，那是我第一次开口说话，爸妈都很高兴，怪不得呢，就这件小事，我几乎年年能听到。</p>
<p>只是怪了，小孩开口说话第一个字难道不应该是“妈”或者“爸”吗？到我这怎么变成“有”了？不得其解。也不求甚解。</p>
<p>辗转几路地铁，终于到了。从未来过这里，已经开始在脑补废墟之上的灯会该是哪般模样。</p>
<p>真是，百闻不如一见，还没有进园，就已经很好看了好吗！我和同行的伙伴不约而同发出了同样的感叹。</p>
<p><img src="/MD_IMG/2019-02-24-light.assets/640-16895056850312.jpeg"></p>
<p>在刚进园不远的地方，便有这样一处景，第一印象是烟雨江南的味道，然后远处的金碧辉煌才更加显现出来。我们直呼这地方太美了太美了，忍不住手机咔嚓咔嚓作响。</p>
<p>而对于成长在鱼米之乡的我来讲，这类水边垂柳的景致，总是更加别有情怀，来北京之后，苏州街，古北水镇，也是都去过，但是不得不说，毕竟是在北方，总还有种格局不够大的感觉，像是被束缚了手脚施展不开。</p>
<p><img src="/MD_IMG/2019-02-24-light.assets/640-16895057105624.jpeg"></p>
<p>置身园中，所见之处，无不是张灯结彩，光芒闪耀，所谓灯会灯会，当是如此了。</p>
<p><img src="/MD_IMG/2019-02-24-light.assets/640-16895057508106.jpeg"></p>
<p><img src="/MD_IMG/2019-02-24-light.assets/640-16895057587408.jpeg"></p>
<p><img src="/MD_IMG/2019-02-24-light.assets/640-168950576431410.jpeg"></p>
<p>园中的各色彩灯花灯让人目不暇接，给人“热闹”或是“蔚为壮观”的感受，有最常见的灯笼错落有致直接铺展开来，有的看起来就像一串串的冰糖葫芦挂在枝头，也有那美美的花灯而我们只需带着欣赏的双眼便足矣，还有对联生肖脸谱灯谜等等，无不展示文化传统，记录着历史脚步。</p>
<p>此间，对那些单个的灯笼倒是情有独钟，一路上也一直在找寻合适的机会记录，想要留下那些瞬间。</p>
<p><img src="/MD_IMG/2019-02-24-light.assets/640-168950577619112.jpeg"></p>
<p><img src="/MD_IMG/2019-02-24-light.assets/640-168950578317014.jpeg"></p>
<p><img src="/MD_IMG/2019-02-24-light.assets/640-168950578723716.jpeg"></p>
<p>有个地方倒是很有意思，这个一看就条件反射，莫不是在催生二胎，手动【哭笑不得脸】。</p>
<p><img src="/MD_IMG/2019-02-24-light.assets/640-168950580085218.jpeg"></p>
<p>这个穿透绿光森林的白月光，仿佛间让人感觉置身于梦幻之中。</p>
<p><img src="/MD_IMG/2019-02-24-light.assets/640-168950581030020.jpeg"></p>
<p>被称为万园之园的园子真是够大，在我们沿路逛了一个多小时之后，才终于是快要接近尾声了，已经快到出口，捕捉到了这样一张，看着就有种“家”的感觉，也不知是缘何如此。</p>
<p>看着那一盏盏的灯笼，以及肃清的门窗，不由得想起家里过元宵最有仪式感的一件事便是“散灯”。</p>
<p>元宵这天晚上，煮好汤圆，一通爆竹燃毕，才表示开饭了。酒足饭饱之后就要去“散灯”，在家中的大小门前点上蜡烛，大门的蜡烛还要额外的大一些，得燃更久一点才好。这也便是前面提及的那篇小文的背景了。</p>
<p><img src="/MD_IMG/2019-02-24-light.assets/640-168950582146522.jpeg"></p>
<p>隔壁故宫的“上元之夜”赚足了眼球，但是有位网友的评论很独到，不过呢，深以为然。</p>
<p><img src="/MD_IMG/2019-02-24-light.assets/640-168950583036924.jpeg"></p>
<p>最后，月是故乡明。</p>
<p><img src="/MD_IMG/2019-02-24-light.assets/640-168950584092026.jpeg"></p>
]]></content>
      <categories>
        <category>随笔</category>
        <category>生活记</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>京城游记</tag>
      </tags>
  </entry>
  <entry>
    <title>书写，是为了铭记？还是忘记？</title>
    <url>/2019/02/28/2019-02-28-to-remember-or-not/</url>
    <content><![CDATA[<p>我从小语文成绩不好，却一直有写写划划的习惯。</p>
<p>年纪小的时候，思考的不多，看的书也不够多，那时候的写日记任务对于我来讲是一项挤牙膏般的折磨，输出不了；另一方面，感叹于世界的缤纷和多彩，有很多未知想要去探索，到处都是可以学习的地方。</p>
<p>但是又察觉到获取信息的方式的匮乏，所以那时就有摘录的习惯，报纸上、杂志上、课外书上、甚至于寒暑假作业上看到的知识点都想要记下来，或者抄录下来，或者直接剪下来贴在本上。家里有不少那时候留下来的本本。</p>
<p>所以，我喜欢记笔记，到了后来，又喜欢把看的书上的原句或者想法记录下来。我想，这些书写和记录，都是想要铭记，记住看过的东西，记住有过的想法，记住曾经的精彩。</p>
<p>上高中的时候，老师们经常说的一句话是，学习是先把书本读厚，然后再慢慢的读薄，你就真的是吃透了它了。</p>
<p>这话很好理解，越读越厚，是丰富了书本的知识点，所谓举一反三、融会贯通，这是不断累积的过程；而越读越薄，则是消化这些知识点，把他们自然融入到脑中的知识体系中，成为有机的一部分，这是真正习得的过程。</p>
<p>最近，和朋友开玩笑说这半年来思考的东西比前半生都多，关于亲情、爱情、工作、婚姻、家庭、生活、理想、意义等等。</p>
<p>话题多半是沉重和严肃的话题，想多了反而是都没有意义了。有心或无意，思考过的东西，存于脑中，或许不会一直占据脑海中心，时不时，总是会挠你一下，多了之后，难免不堪其扰。</p>
<p>这时候，经过有序的组织，写下来之后，仿佛是完成了一个又一个任务，可以放诸脑后，可以 move on 了，有迹可循就不怕忘记它，也就可以光明正大的忘记它，倒是真正轻松了很多。</p>
<p>这就像那个读书越读越薄的过程，占据的脑容量越来越小，不用想起，有可能是化成了另外一种形态。</p>
<p>那么，这些书写和抒发应该，是在整装待发，是要轻装上阵。</p>
<p><img src="/MD_IMG/2019-02-28-to-remember-or-not.assets/image-20230602220731398.png" alt="image-20230602220731398"></p>
]]></content>
      <categories>
        <category>随笔</category>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>你闻见过么？阳光的味道。</title>
    <url>/2019/09/07/2019-09-07-sunlight/</url>
    <content><![CDATA[<p>家在南方的人，想必都有这样一个印象：冬天，赶着天气放晴，阳光很好的时候，必然有那么几天会把家里的衣物被褥都翻出来，去见见太阳。</p>
<p>小的时候，在腊月里，总会赶着天儿好，在年前把屋里的棉衣袄子被褥床垫都拿到楼顶上去，甚至是床板都搬出去在庭前晒晒，见见光。</p>
<p>老妹说，我们姐弟仨都不喜欢干这件大事，虽说干活累且无趣，但是对我来讲，有一点点好，我喜欢闻这阳光的味道。</p>
<p>所以，可能，应该，我是家里收拾这些比较多的一个，比起老弟和老妹。</p>
<p>当爬到楼上，如果天公作美不下雨，如果时间老人不催赶，一般情况下，在收起之前，我都喜欢先凑上去，或者干脆躺在被子上，闻一闻那经过阳光洗浴后的味道，它不香不甜不热不腻也不是清新，而是一种生命力的味道，昂扬向上、欣欣向荣。</p>
<p>然后晚上睡觉的时候，就觉得自己被温暖包围了，睡在了阳光里。</p>
<p>后来大学毕业之后，研究生和工作上班都在北京，渐渐地这个习惯不知道怎么就没了，总认为，北方干燥，不像家里或者武汉那样潮湿，取而代之的，反而加湿器见得多了，以前爱开窗的习惯也没了。</p>
<p>少了一项大工程，但是也失了一点乐趣。</p>
<p>最近觉得，在这一亩三分地，住了快两年了，都没怎么折腾过，不行，突然就想动它一动。</p>
<p>生活就得折腾折腾。</p>
<p>正好，今天趁着周六休息和大太阳，把整个床都搬到三楼的阳台上去沐浴阳光，床垫子、褥子、被子、枕头、靠枕，还有我的娃娃们，该洗的全洗了，毛毯、床单、枕巾…</p>
<p>快夕阳西下了，一边在家里群里通着话，老爸，老妹，有一搭没一搭地唠着磕，一边收拾这些。</p>
<p>当我跑了整整三趟，把它们悉数抱了回来，然后再一点点把床铺好，枕巾盖上，靠枕摆上，把皮卡丘放在枕头边，棕色小熊待在另一角，白色熊熊随意放着。</p>
<p>它陪我最久，快七年了吧，小月买的，记得十分清楚，是大三的时候在武大门口那个超市的二楼一个饰品店，那时候还是个钢铁直女的我，不喜欢这些小女生喜欢的东西，但是也不知为啥鬼使神差一般，就要小月买来送给我。现在有时会抱着睡。</p>
<p>全都是旧物，重新回到它们原来的位置，心里升起了一股温暖和温馨。</p>
<p>就像今天的夕阳。</p>
<p><img src="/MD_IMG/2019-09-07-sunlight.assets/sunlight.jpg" alt="sunlight"></p>
]]></content>
      <categories>
        <category>随笔</category>
        <category>生活记</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>我会想念这个小破园的</title>
    <url>/2020/06/18/2020-06-18-little-park/</url>
    <content><![CDATA[<p><img src="/MD_IMG/2020-06-18-little-park.assets/640.jpeg"></p>
<p>小区南边隔一条马路是个公园，明显没有完工，像是个烂尾工程。</p>
<p> 傍晚时分，天将夜，初夏的凉风吹过来，公园里丛生的高高杂草，一浪又一浪，此起彼伏，有点像以前穿梭在田埂间的夏天，四周种满水稻，单季稻长很高，田埂高出水田那么多，稻禾也能轻松过膝，像现在这样，一时错觉顿生。</p>
<p><img src="/MD_IMG/2020-06-18-little-park.assets/640-16894999716582.jpeg" alt="杂草高长"></p>
<p>我已经很久没有见过水稻茁壮生长的模样，研究生之后一年才回一次家，有很多东西都早已只是记忆中残存的画面。却没想到，今年冬天因为疫情的缘故，时间有了，也不用走亲戚，也没法走街串巷，反倒上山下地成了唯一的选项。</p>
<p> 于是出去看了看，真是久违了，也确实面目全非了。山给挖没了，湖给填平了，新开的路又直又宽，原来的小道消失了痕迹，也是，又一个工业开发区要建起来了，自然当是如此。</p>
<p> 只有它们，还是原来的样子，这些粮食作物，不管耕作方式怎么改变怎么先进，它们生长的样子，收割之后残留的桔梗，永远都是这样。</p>
<p><img src="/MD_IMG/2020-06-18-little-park.assets/640-16894999953784.jpeg" alt="水稻收割之后，一如旧时模样"></p>
<p>这时，天空中不时飞过几架飞机，仔细听听，伴着轰隆轰隆的响声，这应该去往首都机场的飞机。以前在北京的西北边比较少看见飞机，最近发现多了起来，不知道是不是错觉，也许是因为南边那个新建的网红机场–大兴机场，没有求证，我猜的。</p>
<p> 路灯下，借着光刚好看见路边的不知名小小树上，竟结了很多小果子。叫不上名字，想要摘下尝尝，一是怕被人说毁坏公物，二则没了啥都吃一吃的虎胆和兴致。</p>
<p><img src="/MD_IMG/2020-06-18-little-park.assets/640-16895000226066.jpeg" alt="无名果"></p>
<p>路上偶遇几个行人，戴着口罩或是嫌麻烦已经将其摘掉，领着小孩，或是三两为伴，都是出来闲逛散步的。别小看这个小破园，每天可是热闹的很。常常周末懒得出门瞎玩瞎闹了，到了傍晚就到这里转几圈，活动活动筋骨，也呼吸呼吸外面的空气。</p>
<p> 耳机里放着新裤子的《夏日终曲》，看着这参差不齐、乱七八糟的树木花草，升起了奇奇怪怪的亲切感。</p>
<p><img src="/MD_IMG/2020-06-18-little-park.assets/640-16895000383518.jpeg" alt="不知道是什么 · 花"></p>
<p>很多人以为花草树木就是城市里公园里样子，但是每次看到它们，我都觉得是盆景盆栽，供人把玩的，一个个的都身不由己。</p>
<p> 所以，喜欢这个杂乱无章的野蛮生长的小公园，正是它的不规不矩才让我喜欢，它们高矮不一，它们参差不齐，它们拍照不好看，但是这样的才是真实的，亲切的，生机的，，，如果只见过平平整整的草坪，修剪如一的灌木，行列有序的树林，那就有点，可惜了了。</p>
<p> 然而，莫说别人，即使是我自己，也不会再有机会，在阳春三月里，从那漫山遍野的映山红中，去找寻最喜欢的鲜红的、纯白的那几枝；在夏日趁着朝露采摘栀子花，就为了抿那一滴花心尖儿上甘甜……</p>
<p>只是没想到，这么快，我就要搬家了。</p>
<p> 我会想念这个小公园，和在这里的时光。</p>
<p><img src="/MD_IMG/2020-06-18-little-park.assets/640-168950005593110.jpeg"></p>
<hr>
<p>写在后面：</p>
<p>不知道为什么，不管是平常说话聊天，还是在这里随便写写的时候，我发现自己总是不可避免的在遥想当年，但是我其实并不追忆过去，也不想回到过去。</p>
<p>可能我只是喜欢和想象某一些特定的时刻事件，并不想再过那时的生活。因为自己知道，我会格外想念那几枝鲜见的映山红，是因为小时候也有很多事情要做，并不能像别的小朋友一样随时随地去采摘去玩耍。</p>
<p>我认真想了想，过去发生的事情，不管好的坏的，都是根植在了生命里的，这些生活轨迹造就了我自己，否定它就是否定自己。</p>
<p>我喜欢这个小园子，多半也是因为，在这个大城市里，它距离我原来十几二十年的生活相对更接近。</p>
<p>本能上，人不会趋向于否认自己；回忆，从某种程度上讲是一种认可。而人的记忆是个强大的筛子，它往往更多地记住美好的部分，下意识忽视掉不开心的成分。</p>
<p>过去的美好，只能鲜活的存在于回忆里和画面中，经不住再来一遍。</p>
<hr>
<p>高中英语作文有句万能结尾</p>
<p>LAST BUT NOT LEAST… </p>
<p>放这里怪合适的</p>
<hr>
<p>周末时常来逛</p>
<p>拍了好些个奇奇怪怪的照片</p>
<p><img src="/MD_IMG/2020-06-18-little-park.assets/640-168950025613720.jpeg" alt="遗世而独立"></p>
<p><img src="/MD_IMG/2020-06-18-little-park.assets/640-168950016047312.jpeg" alt="又是被线条俘获的一天"></p>
<p><img src="/MD_IMG/2020-06-18-little-park.assets/640-168950022837418.jpeg" alt="回忆里满是这样的小路"></p>
<p><img src="/MD_IMG/2020-06-18-little-park.assets/640-168950021261216.jpeg" alt="日落西山红满天"></p>
<p align="center">这</p>
<p align="center">里</p>
<p align="center">需</p>
<p align="center">要</p>
<p align="center">一</p>
<p align="center">个</p>
<p align="center">小</p>
<p align="center">预</p>
<p align="center">警</p>
<p align="center">~</p>
<p align="center">有点子阴森可怕的氛围</p>


<p><img src="/MD_IMG/2020-06-18-little-park.assets/640-168950017076514.jpeg"></p>
<p align="center">【写于2020.6.18，搬运至此】</p>
<p align="center">---END---</p>]]></content>
      <categories>
        <category>随笔</category>
        <category>生活记</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>日子</title>
    <url>/2020/08/08/2020-08-09-life/</url>
    <content><![CDATA[<p>再有几天，就正式迈进二十八了。 </p>
<p>生活中的“四舍五入”都是潜移默化悄无声息的。当我还是27的时候，觉得自己和25没什么差别，但是一到28，就感觉是和30差不离了。如此一来，等真正到而立之年的时候，感受反而有可能会弱化，毕竟经过两年的预热期，有一种“我已经准备了两年”的平静感。</p>
<p>回望这最近三年，想来除了参加工作开始自己养活自己，竟然没有什么特别值得回忆和铭记的事情，山山水水草原沙漠的去过一些，就去年的这个时候还乐此不疲，现在一想细思极恐，去年那个我不是我了似的。</p>
<p>谁能想到一年后我也能成了周末宅，白天一睡睡半天，晚上还照睡不误，哪像是原来那个满脑子都是烧烤啤酒KTV、漂流骑车登长城的，还有，连跟鞋都懒得穿了，竟然也会认为麻烦累赘，始料未及。</p>
<p>原来那些彼时彼刻很疯狂很肆意爽快的事情，到往后的日子，最终都变成一个个的谈资，在饭桌上、应酬中，假模假样的遥想当年、挥斥方遒。而生活需要的终究不是这些，而是精神的满足。</p>
<p><img src="/MD_IMG/2020-08-09-life.assets/640.jpeg"></p>
<p>我们追求物质也好，追求刺激也罢，说到底都是追求精神的。人们真正渴望的，并不是极限运动中的一次次尖叫和肾上腺素的飙升，不过是因为内心空虚无所支撑，需要填满一些，假装自己的精神世界很富足；也不是为了那一张张的RMB，而是它能带来的自由，选择的自由。</p>
<p>只有单一选项的选择不叫选择，只能称作迫不得已和无可奈何。</p>
<p>再往前细数…… 嗐，其实也不用细数了，之前的大多数日子，要么是活在旁人的期待里，要么是没心没肺什么也不想。</p>
<p>当然并不是否定这些，正是这些来自于亲人朋友的期待，而我也希望满足的这些期待，让我在从前完全不知道前路的“小时候”，能够走在一条比较正确的道路上，让我认真学习好好生活，然后大学读研工作一路过来，一步一脚印，踏踏实实地过着日子。</p>
<p>此时十分应景的想到了，龙应台写给儿子安德烈的信中的一段话：“孩子，我要求你读书用功，不是因为我要你跟别人比成绩，而是因为，我希望你将来拥有选择的权利，选择有意义、有时间的工作，而不是被迫谋生。当你的工作在你心中有意义，你就有成就感；当你的工作给你时间，不剥夺你的生活，你就有尊严。成就感和尊严，给你快乐。”</p>
<p><img src="/MD_IMG/2020-08-09-life.assets/640-16894982402682.jpeg" alt="怀柔~雁栖湖"></p>
<p>刚刚看乐夏，康姆士主唱永驻说道：“人生就是因为充满失败才值得我们去努力。”</p>
<p>夜深人静了，又开始思考人生了。</p>
<p>真的有人明明白白知道自己想要把生活过成什么样吗？</p>
<p>如果是，那着实羡慕；</p>
<p>还是说，迷茫其实就是人们最真实的常态，不管是青春洋溢十几岁，热情澎湃二十岁，瞻前顾后三十岁，还是中年危机四十岁……</p>
<p>答案不得而知。</p>
<p><img src="/MD_IMG/2020-08-09-life.assets/640-16894982708444.jpeg" alt="筒子河~故宫护城河"></p>
<p>一直以来我都是不知道的。</p>
<p>小的时候，我希望父母开心满意，我喜欢也享受爸妈说到他家闺女时自豪满足的笑容，那是我尽我所能把事情做到最好的原动力；</p>
<p>后来，我希望生活精彩，热情绚烂，唱最响亮的歌，去最远的地方，走到腿脚没力气，喝到脑子微醺，然后就切换到话痨模式各种夸人，“见人说人话见鬼说鬼话”，好开心。就想要那种为了“赴你一面之约”，可以“从远方赶来”，只想着要是能够“生如夏花”那可真是太好了；</p>
<p>诶，在经历了生活的敲打之后，终于明白生活不会一直绚丽多彩，我们也不可能一直快乐，都会历经低潮消沉甚至容易沉浸其中麻痹自己，努力了但真的，要开心好难啊，对着镜子假笑欺骗自己欺骗别人的样子，转头其实就是沉默着流泪。</p>
<p>今天乐夏中大张伟说的一句话很戳心窝儿“有些东西不能碰，一碰就是泪汪汪。”</p>
<p><img src="/MD_IMG/2020-08-09-life.assets/640-16894983346226.jpeg"></p>
<p>虽说“成就感和尊严能给人快乐”，但当真快乐不起来的时候，就不逼着自己开心快乐了，其实只要没有不开心就好了不是吗。</p>
<p>当每个周末在隔壁的装修噪音中被吵醒，那个脾气真是一下就上来了；遇到一个糟心的室友，能让人崩溃无所求；家人的不切实际空幻想能让人气到跳脚；恰好合作一个带不动的partner也能让人吐槽吐不完；还有让人哭笑不得的表演加班又是为了什么……</p>
<p>所以对喽，不要不开心就好了，先把眉头舒展开，简单一点就好了。</p>
<p>久而久之，日子这样的一面。简单的一面。就像这篇文字中的每一幅插图一样。关注如水一样的点滴细节。</p>
<p>下班之后小区楼下遛弯，看着跳舞的大妈，还有夜归的人们。</p>
<p><img src="/MD_IMG/2020-08-09-life.assets/640-16894983846608.jpeg" alt="晚饭后在唐家岭小区外边散步"></p>
<p>我想骑着我的单车，去看很多风景，这一次是到了午门。</p>
<p><img src="/MD_IMG/2020-08-09-life.assets/640-168949845975912.jpeg"></p>
<p>然后沿着京密引水渠……</p>
<p><img src="/MD_IMG/2020-08-09-life.assets/640-168949847817114.jpeg"></p>
<p> 沿途，每一段距离就有一座这样的小桥。</p>
<p><img src="/MD_IMG/2020-08-09-life.assets/640-168949849894916.jpeg"></p>
<p>遇见这样的故宫。</p>
<p><img src="/MD_IMG/2020-08-09-life.assets/640-168949855090922.jpeg"></p>
<p><img src="/MD_IMG/2020-08-09-life.assets/640-168949855886224.jpeg"></p>
<p>几个月前满树花开，已经结了果。</p>
<p><img src="/MD_IMG/2020-08-09-life.assets/640-168949856974826.jpeg"></p>
<p><img src="/MD_IMG/2020-08-09-life.assets/640-168949857920328.jpeg"></p>
<p>追光。</p>
<p><img src="/MD_IMG/2020-08-09-life.assets/640-168949859422030.jpeg"></p>
<p align="right">以后每次看到这张照片</p>

<p align="right">都会想起艰难的2020年刚开始的时候</p>

<p align="right">有一天，我们在河堤上追着太阳，奔跑</p>

<p align="right">要去留下这一刻的光芒万丈</p>



<p align="right">【写于2020.8.8，搬运至此】</p>

 

<p align="center">---END---</p>

<hr>
<p>PS：康姆士好好听，主唱声音好有味道。</p>
<p>PPS：感叹一下，这一期终于不像上一期那样稀碎了。</p>
<p>PPPS：我可真的太喜欢五条人了哈哈哈哈哈哈哈哈哈哈哈哈…… </p>
]]></content>
      <categories>
        <category>随笔</category>
        <category>生活记</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>就……不是很有分享欲了</title>
    <url>/2020/09/30/2020-09-30-share/</url>
    <content><![CDATA[<p><img src="/MD_IMG/2020-09-30-share.assets/640.jpeg" alt="这是今天的收获，就放这里了"></p>
<p>我又双叒叕停更了好一段时间，收到的朋友的催更信息不知凡几。（彼时还在微信公众号）</p>
<p>其实没那么忙，毕竟体制内。</p>
<p>要问为什么，不是忙，不是没得想说，就是…没啥表达欲分享欲了。</p>
<hr>
<p>看乐夏2心态的起起伏伏到后来沦为不下饭综艺只为五条人；</p>
<p>多次想再去趟故宫结果一波三折至今没成行；</p>
<p>以及看《贞观长歌》《汉武大帝》这些历史剧的颇多感慨，也顶多让我又多了解了一下五代十国的人间惨剧；</p>
<p>前些天还心血来潮报了个国庆期间志愿者；</p>
<p>……</p>
<p>有时候想要一吐为快，但每次等到有时间打开电脑，没敲几个字，就继续不下去了，距离想要say something 的时间点越久，那个分享欲就越发的被稀释，不断被注水变淡。</p>
<p>又或者，一直在等那个100分的状态，要在一个周末，没有工作不用加班，睡饱了，家里收拾舒服了，喝一杯咖啡，连上小音箱，放着石进的钢琴曲……可想而知，这种机遇少之又少，并且真正达到的时候，仪式感倒是满满的，然而那股子劲儿也随着仪式感的完成而消失了，更有甚者……此时极有可能只想打开一部剧，吃点啥喝点啥，舒舒服服地kill time。</p>
<p>两年前，刚注册这个号的时候，脑海里的蓝图中，看书要写读后感，观影要有心得，听到一首歌也要分享出来，然而慢慢地，都在变化…</p>
<p>现在这个时候，想的是，我自己喜欢的东西喜欢着就好了，喜欢九连，喜欢刺猬，喜欢很多，自己心里默默喜欢，再喜欢就买买专辑去去音乐节，就只是喜欢而已。</p>
<p>不知道日后，还会不会把那些发在微博里细细碎碎的东西，音乐评论的大论小论，拍过的照片……再给整出来。</p>
<p>要我说都好，不记录，留下的都是精髓，小时候躺在鲇鱼口山坡上看蓝天白云的场景，没有任何实体记录，但永远留在我心中；另一面，看着从前自己写下的东西却感到那么陌生，也是奇妙的体验。</p>
<p>都是缘分。</p>
<p><img src="/MD_IMG/2020-09-30-share.assets/640-16895034563572.jpeg" alt="这张图应当名为 · 岁月如歌"></p>
<hr>
<p>全篇的图片和音乐，都是自己暗戳戳留的彩蛋，且看日后，我还看不看得懂</p>
<hr>
<p>好了，现在可以回答了，已经忘得差不多了，</p>
<p>倒是还记得，当时老爸看见后，以为首图是我认识的什么特别的新朋友，兴奋不已哈哈哈哈~</p>
<hr>
<p>微信平台的图片放到这里来，比例都好奇怪~~</p>
]]></content>
      <categories>
        <category>随笔</category>
        <category>生活记</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>月满</title>
    <url>/2021/07/26/2021-07-26-moon/</url>
    <content><![CDATA[<p><img src="/MD_IMG/2021-07-26-moon.assets/640.jpeg"></p>
<p align="right">图摄于2019年中秋夜</p>

<p>周六西单小聚</p>
<p>结束时已快九点</p>
<p>朋友车停在了长安街南边</p>
<p>步行前往，抬头见月</p>
<p>月亮很低很低</p>
<p>像是飘在高楼上</p>
<p>又恰逢天朗无云</p>
<p>不似那般轻柔</p>
<p>透着一份肃穆却不清冷</p>
<p>将那剔透的玉盘</p>
<p>藏在面纱之下</p>
<p>月暖纱轻</p>
<p>直至天安门</p>
<p>目光一直追着这暖月</p>
<p>此时从车窗望出去</p>
<p>目之所及是广阔无人的广场</p>
<p>右前方是庄严大气的国博</p>
<p>天空此时是静谧深邃的藏蓝色</p>
<p>在这幅画中</p>
<p>轻纱掩面的圆月</p>
<p>低悬于东南</p>
<p>心有一念油然而生</p>
<p>这就是中国风吧…</p>
<p>这就是中国风</p>
<hr>
<p align="right">光影留不住，手机难定格  </p>

<p align="right">只余这简陋的文字  </p>

<p align="right">却也写不出那十之一二  </p>

<p align="right">但求在某一天再见时  </p>

<p align="right">能唤起彼时彼刻的画面  </p>

<p align="right">足矣，毕竟  </p>

<p align="right">眼睛看到的风景 ，是最美  </p>

<p align="right">化成回忆，便更是无与伦比  </p>

<hr>
<p>北京近日多雨，一个晴朗的周末实属难得。</p>
<p>爸妈在江西老家，已经连续半个月高温天气了，高温预警下了一道又一道，眼看着就要有旱情。</p>
<p>杭州受烟花台风的影响，暴风雨毫不留情地袭来，老弟已经开始 home office了。</p>
<p>相比之下，老妹和我这边算好的，虽然也是风雨不断。</p>
<p>一家人天南地北，一路求学，工作生活，这应该也是当下很多家庭的常态。</p>
<p>月缺月满，</p>
<p>都只愿人们能够，</p>
<p>归期有期，团圆有时。</p>
<p align="center">---END---</p>
]]></content>
      <categories>
        <category>随笔</category>
        <category>生活记</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>京城游记</tag>
      </tags>
  </entry>
  <entry>
    <title>那只橘猫</title>
    <url>/2021/12/22/2021-12-22-dream/</url>
    <content><![CDATA[<p><img src="/MD_IMG/2021-12-22-dream.assets/640.jpeg"></p>
<p>昨晚梦见了一只橘猫</p>
<p>很多细节我不记得了</p>
<p>唯记得它有思想能说话也动感情</p>
<p>我很喜欢它</p>
<p>但是不知道是什么传达给我的讯息</p>
<p>它似乎是很危险的</p>
<p>就在那时</p>
<p>我碰到它手上就很多毛</p>
<p>好像在告诉我这就是危险</p>
<p>我明明知道</p>
<p>但是我好像被它感染了感动了</p>
<p>尽管知道它危险还是没有离开它</p>
<p>至少在这个梦里</p>
<p>它不只是一个动物</p>
<p>那时候它就是和我们人一样的</p>
<p>~</p>
<p>不止如此</p>
<p>我还有些羡慕它</p>
<p>羡慕什么呢</p>
<p>像是它是带着悲情色彩来的</p>
<p>来这人间看我们的戏的</p>
<p>它好像什么都知道</p>
<p>连它自己的悲剧命运它也知道</p>
<p>不止是悲情了</p>
<p>是悲壮了</p>
<p>我好像羡慕的是这个</p>
<p>因为自己是无知的</p>
<p>是没什么作为的</p>
<p>是无比平凡的</p>
<p>是连平凡中的一点伟大也没有的</p>
<p>但是做这个梦的时候</p>
<p>我觉得自己是深刻的</p>
<p>那个时刻</p>
<p><img src="/MD_IMG/2021-12-22-dream.assets/640-16895020301612.jpeg"></p>
<p>不知所云地说了很多</p>
<p>还是没有表达出梦里的我的心情</p>
<p>做完这个梦我醒了</p>
<p>也许梦还没完</p>
<p>我知道等早上起来我会忘了的</p>
<p>所以再次入睡前我还回想了一遍</p>
<p>白天起来果然还是忘了</p>
<p>这个预见是多么准确</p>
<p>后悔没有当时就记下来</p>
<p>如果不是白天遇到一条狗</p>
<p>可能也不会想起这一点点</p>
<p>也不知道该不该高兴</p>
<p>–</p>
<p>我想</p>
<p>等到以后</p>
<p>再说起这个梦</p>
<p>开头就是</p>
<p>“我做过一个梦</p>
<p>但是我不太记得了</p>
<p>不过我唯一确定的是</p>
<p>我很喜欢它”</p>
<p align="center">---END---</p>]]></content>
      <categories>
        <category>随笔</category>
        <category>有所梦</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>第一次做芝士蛋糕，太好吃了！</title>
    <url>/2021/12/26/2021-12-26-cake/</url>
    <content><![CDATA[<p><img src="/MD_IMG/2021-12-26-cake.assets/640.jpeg" alt="必须先展示成果"></p>
<p>新的烤箱到了，迫不及待地想要尝试一下，虽然从来没有做过，但是我们坚信可以做到！</p>
<p>虽然盲目自信，但是终是成功了，非常非常好吃，忍不住要来分享一波。</p>
<h2 id="工具与食材"><a href="#工具与食材" class="headerlink" title="工具与食材"></a>工具与食材</h2><p>在网上找了很多资料，最终主要是参考B站的这个视频做的。【芝士蛋糕】全网最详细教程日式轻乳酪蛋糕，舒芙蕾芝士蛋糕<em>哔哩哔哩</em>bilibili</p>
<p><a href="https://www.bilibili.com/video/BV1Av411A7kE">https://www.bilibili.com/video/BV1Av411A7kE</a></p>
<p>首先准备工具和食材。</p>
<h3 id="工具："><a href="#工具：" class="headerlink" title="工具："></a><strong>工具：</strong></h3><ol>
<li>蛋糕模具，6英寸大小</li>
<li>烤纸</li>
<li>锡纸</li>
<li>烤盘+烤架</li>
<li>较大不锈钢打蛋盆</li>
<li>蛋黄分离器</li>
<li>手动打蛋器，电动打蛋器</li>
<li>面粉筛</li>
<li>橡胶刮刀</li>
<li>烤箱内部温度计</li>
</ol>
<h3 id="食材："><a href="#食材：" class="headerlink" title="食材："></a><strong>食材：</strong></h3><ol>
<li>奶油芝士：180g</li>
<li>无盐牛油：30g + 另用于涂抹模具的部分大概3-5g</li>
<li>牛奶：100g</li>
<li>鸡蛋：3颗</li>
<li>香草精：2.5g</li>
<li>食盐：2g</li>
<li>低筋面粉：20g</li>
<li>玉米淀粉：10g</li>
<li>塔塔粉：2g</li>
<li>细砂糖：65g</li>
</ol>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h3><p>以上工具与食材为从上述视频中总结的。在实际做的过程中，有一些些的调整和改动。具体的替代和感受：</p>
<p>【工具篇】</p>
<ol>
<li>烤纸的作用不是不可替代，省去了；</li>
<li>烤盘烤架用了现有的工具替代；</li>
<li>打蛋盆这个得买，虽然这次用了玻璃水果盆，但是时时都在担心要被电动打蛋器给整废了；</li>
<li>手动打蛋器也没有，用了电动打蛋器的一个头替代，还是不太方便；</li>
<li>橡胶刮刀没有，用的电饭锅的铲子，不好用；</li>
<li>温度计没有，在烤的过程中有一点点波折，温度控制不够好；</li>
<li>最终，打蛋盆、手动打蛋器、橡胶刮刀、温度计都已经在路上了，得买！</li>
</ol>
<p>【食材篇】</p>
<ol>
<li>黄油替代无盐牛油（淡味黄油就约等于无盐牛油了）</li>
<li>香草精、塔塔粉没放，似乎对口感没什么影响（猜的，也可能放了更好吃，只是咱也没试过，不知道）</li>
<li>低筋面粉，这个真得吐槽，小区超市竟然没得卖，只有小麦粉。然后网上搜罗，说是小麦粉是高筋面粉，也约等于饺子粉，蛋白高，但是可以用小麦粉和玉米淀粉1:1混合，就能替代低筋面粉了。虽然将信将疑，但是也没得办法，不过经过这次实验，亲测有效！</li>
</ol>
<h2 id="制作过程"><a href="#制作过程" class="headerlink" title="制作过程"></a>制作过程</h2><p>然后就是考试制作了，参考视频，主要步骤如下：</p>
<h3 id="模具部分"><a href="#模具部分" class="headerlink" title="模具部分"></a><strong>模具部分</strong></h3><ol>
<li>在模具内侧涂抹无盐牛油，防止蛋糕完成后褪去模具时粘连蛋糕（用黄油代替无盐牛油）</li>
<li>模具底部垫上烤纸，作用同上一步，帮助脱模（这一步可省略）</li>
<li>在蛋糕模具底部包两层锡纸，防止水&#x2F;水蒸气渗透进入</li>
</ol>
<h3 id="蛋黄糊"><a href="#蛋黄糊" class="headerlink" title="蛋黄糊"></a><strong>蛋黄糊</strong></h3><ol>
<li>准备一个较大的不锈钢打蛋盆，放入180奶油芝士，30g无盐牛油，100g牛奶</li>
<li>用中小火隔水加热，并用打蛋器捣碎成小块，一边搅动一边加热，直到软化融化顺滑</li>
<li>然后离火，加入三颗鸡蛋的蛋黄，放入一个就用打蛋器搅碎完全融化均匀，依次完成三个蛋黄的融合</li>
<li>加入2.5香草精，2g食盐，并混合均匀</li>
<li>20g低筋面粉，10g玉米淀粉，用面粉筛过筛后加入面糊中</li>
<li>用打蛋器进行混合，最好用Z型翻拌，防止过度搅拌，这时是一个比较顺滑较稀的状态</li>
</ol>
<h3 id="蛋白霜"><a href="#蛋白霜" class="headerlink" title="蛋白霜"></a><strong>蛋白霜</strong></h3><ol>
<li><p>将三个鸡蛋的蛋清一起放入一个较大的打蛋盆中，并放入2g塔塔粉</p>
</li>
<li><p>用电动打蛋器，中速打发，直到出现大的气泡（应该需要20多分钟）</p>
</li>
<li><p>分三次加入细砂糖65g，并打发</p>
<p>第一次，加糖后中速打发，直到气泡变小，出现软软的浅浅的纹路</p>
<p>第二次，加糖后中速打发，直到气泡变得绵密，纹路更深，开始出现光泽</p>
<p>第三次，加糖后低速打发（可以消除大气泡），直到纹路明显，有光泽</p>
</li>
<li><p>测试浓稠度，打蛋器提起来后有个大弯勾，这时候整个盆倒扣不流动，这样就可以，不要打发过度，否则会有大气泡，蛋糕容易开裂</p>
</li>
<li><p>用刮刀翻拌一下边缘</p>
</li>
</ol>
<p><img src="/MD_IMG/2021-12-26-cake.assets/640-16895051248952.jpeg"></p>
<h3 id="整合"><a href="#整合" class="headerlink" title="整合"></a><strong>整合</strong></h3><ol>
<li>用打蛋器翻拌前面准备好的蛋黄糊，松弛一下</li>
<li>取大概三分之一蛋白霜加入蛋黄糊中，用打蛋器轻轻翻动混合均匀，不要打圈搅拌</li>
<li>用刮刀刮边缘和底部，翻拌均匀</li>
<li>用打蛋器轻轻搅拌松弛一下蛋白霜</li>
<li>将蛋黄糊全部倒入蛋白霜中，用打蛋器混合，再用刮刀刮边缘和底部，混合均匀，直到看不到白色的蛋白霜，注意不能过度翻拌，防止蛋白霜消泡</li>
<li>将混合好的面糊倒入模具中，过程中可以看到彩带状，倒入后便又会马上消失</li>
<li>用一根筷子在面糊中从大到小画圈，消除气泡，端起模具轻轻震几下</li>
</ol>
<h3 id="准备放入烤箱"><a href="#准备放入烤箱" class="headerlink" title="准备放入烤箱"></a><strong>准备放入烤箱</strong></h3><ol>
<li>备一个较大的烤盘，烤盘里装一部分热水，再放上烤架，水的位置差不多刚好碰到烤架</li>
<li>模具放于烤架上</li>
</ol>
<h3 id="放入烤箱烘焙"><a href="#放入烤箱烘焙" class="headerlink" title="放入烤箱烘焙"></a><strong>放入烤箱烘焙</strong></h3><ol>
<li><p>上下火，不开旋风，最底层烤，最好有温度计，分三步</p>
</li>
<li><p>温度200℃，18min，（因为有水，内箱实际温度大概为190℃），</p>
<p>这时转动一下蛋糕模具（此时蛋糕已经开始变色并略微膨胀起来了）</p>
</li>
<li><p>温度160℃，12min（调整温度后，内箱温度会慢慢降至165℃左右）</p>
<p>蛋糕继续膨胀，会高出模具一部分，并可能会小部分裂开属正常</p>
</li>
<li><p>温度110℃，70min（温度继续调整，内箱温度会慢慢降至100℃左右）</p>
<p>降温后，之前膨胀会部分回缩，</p>
</li>
<li><p>60min后，用筷子测试熟度，筷子上如果还有蛋糕渣就继续烤5-10min</p>
</li>
<li><p>继续测试，测试蛋糕边沿就可以，干净没渣就好了，但是，每个烤箱有它自！己！的！脾！气！</p>
</li>
<li><p>取出，室温放凉，蛋糕和模具之间有细缝，可自动脱模</p>
</li>
<li><p>热的时候切开，刀口比较细腻</p>
</li>
<li><p>放入冰箱冷却后，就可以开吃了</p>
</li>
</ol>
<h3 id="备注："><a href="#备注：" class="headerlink" title="备注："></a><strong>备注：</strong></h3><p>以上打蛋器和刮刀的使用，基本是基于他们的特点，打蛋器可以相对比较快混合，但部分边缘和底部可能不能完全顾及。</p>
<p><img src="/MD_IMG/2021-12-26-cake.assets/640-16895052022704.jpeg" alt="正在烤箱中的蛋糕，开始膨胀，已经有香味了"></p>
<p><img src="/MD_IMG/2021-12-26-cake.assets/640-16895052127326.jpeg" alt="关于刀口，热切刀口细腻，冷切就粗糙多了，左边是刚做好的时候，还是热的时候切的，右边是冰箱冷却一晚后，隔天早上切的"></p>
<h2 id="随想"><a href="#随想" class="headerlink" title="随想"></a>随想</h2><p>自己在家里做自己喜欢的好吃的，是一件非常的事情，同时，也有可能是件比较煎熬的事情。</p>
<p>这回前期开始准备动手，到蛋糕液放入烤箱，这中间有两个多小时的时间，从晚上七点多开始到将近十点，还有很多是两个人在同时操作。</p>
<p>就比如打蛋白霜，看起来只有几行字，但这个过程就要近一个小时，打好之后也要尽快放入烤箱，否则容易消泡。</p>
<p>在制作蛋黄糊的过程中，有一个跟视频中不太一样，上面是一开始搅拌好之后要离火，但是也不知道是不是因为北京太冷，一拿下来就要冻住了，所以我们这基本搅拌全程都是在小火温着。</p>
<p>这就导致，放蛋黄的时候，生怕一个手脚不够快，鸡蛋就给我熟了。<img src="/MD_IMG/2021-12-26-cake.assets/640-16895052618198.png" alt="图片"><img src="https://mmbiz.qpic.cn/mmbiz_png/S1mpTWPMtBoSZqZWHiaK6c99JDib6JV0sjrkyTUC0aZITFPaGh0BjxK3kkM9KnCZhhgl8KjHq0Mqbq1hAGoC3qFw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>好吧，我已经不知道还要说什么了，我想，即使这次没有成功，我依然会很开心的，这大概就是美食的魔力吧。我收回曾经大言不惭说过的对吃的没什么兴趣的话。</p>
<p>当然，不成功是不存在的。</p>
<p>当。当。当。当。。。</p>
<p><img src="/MD_IMG/2021-12-26-cake.assets/640-168950529813310.jpeg"></p>
<p>当我看到成品，我的心都要化了。</p>
<p>为了尝到这第一口的蛋糕，我洗漱都刻意没有刷牙，此时已经晚上十二点多了，真是的太不容易了。</p>
<hr>
<p>今天早上的美味早餐。</p>
<p>从未吃过如此好吃的蛋糕。</p>
<p>看来，我也并不是不爱吃甜食，只是一定要吃好吃的甜食。</p>
<p><img src="/MD_IMG/2021-12-26-cake.assets/640.jpeg"></p>
]]></content>
      <categories>
        <category>随笔</category>
        <category>生活记</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>一些吃吃喝喝</tag>
      </tags>
  </entry>
  <entry>
    <title>我 emo 了</title>
    <url>/2021/12/28/2021-12-28-emo/</url>
    <content><![CDATA[<p><img src="/MD_IMG/2021-12-28-emo.assets/640.jpeg"></p>
<p>按如今的时髦话来讲，我 emo 了……</p>
<p>今天我似乎慢慢地慢慢地，然后就突然陷入了虚无。</p>
<p>不想说话，不想起身，不想脱掉厚重的羽绒服；想起周末的时候又是去抓娃娃、又是做蛋糕、还饶有兴致地总结步骤发出来，也觉得索然无味、意兴阑珊了；本来一直在整理的什么年末总结啊，电影体会啊啥的，也都提不起兴趣继续写下去了；甚至于，作为到单位来点卯的人，我早该下班回家了，但是也迈不出这个脚步。</p>
<p>觉得所有这些东西其实挺没意思的，回家了会干嘛，用脚趾头都想得到，肯定是大多时间，对着手机看一些我并不想看的东西，玩着毫无营养的游戏，kill time，但是明明我并不是要消磨时间，时间很宝贵啊，但是这个念头就像是脑海里一缕缥缈的轻烟，太没有分量，任谁都能轻易把它拨开。</p>
<p>而那些所谓的码字，也是没有什么具体意义的事情，于技术无长进，于能力无提升，就是自己在自家的后花园自说自话自娱自乐罢了。</p>
<p>看看我们的生活，被割裂成了好多个部分，好看的剧要追，有价值的电影要看，有意思的事要做，热门的地方要去玩，世俗的节日要过……要通过这些来证明什么一样，不然就怎么怎么样了，和大众脱节了，显得不合群了。</p>
<p>这该死的从众心理和随波逐流。</p>
<p>谁都知道太在意他人的眼光容易自己累，但是我们又不确定自己的眼光是不是对的，万一自己走眼了呢。就算不求成功，但也不希望真就过成了世俗意义上的失败。所以就在一路想要自我的路上左顾右盼，偶尔把自己丢出去对比一番，好了，已经慢慢看出这股别扭劲儿了。</p>
<p>于是我们常常分身乏术，干什么的时间都不够，干脆就…算了，玩会儿游戏吧，刷会视频吧…… 结果往往就是，想做的时候大多没有做成自己想要的样子，花费最多时间耗费最多精力的，反而是游戏短视频这类的精神鸦片一般的东西，然后又开始懊恼、开始悔不当初、开始焦虑、开始重新计划……</p>
<p>这时候我又开始自己开导自己了，人生那么长又那么短，并不是干什么事情都是要有意义的，很多时候没有意义就是这件事本身的意义。或许我们可以从这里获得一点满足感，得到一份简单的快乐，汲取一点能量，就已经足够，就像是在充电。</p>
<p>况且，人生本就是没有意义的，意义是人赋予的。比起生物学上的人由一个个细胞构成，其实更愿意把人看做是各种情感和连接的组合，是不同的感情丰富了我们，是喜怒哀乐、是悲欢离合让人生变得有一点点颜色，还有此时此刻的emo。</p>
<p>emo本身也是人生的一部分。</p>
<p>而且，生活继续着，才不管你呢。</p>
<p><img src="/MD_IMG/2021-12-28-emo.assets/640-16895015630042.jpeg"></p>
<p><em>我一直认为，万物都是有缘由的，</em></p>
<p><em>虽然不一定按常理。</em></p>
]]></content>
      <categories>
        <category>随笔</category>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>SLAM数学基础（一）：向量与矩阵</title>
    <url>/2023/06/04/2023-06-04-vector/</url>
    <content><![CDATA[<h2 id="1-基础概念"><a href="#1-基础概念" class="headerlink" title="1 基础概念"></a>1 基础概念</h2><p><strong>点</strong>：点是空间中的基本元素，没有长度，没有体积。</p>
<p><strong>基</strong>：基（Basis）是张成一个空间的一组线性无关的向量（有些书中也叫基底）。一个空间的基是有任意多组，但一组基只能张成一个空间。</p>
<p><strong>向量</strong>：既有大小（长度），又有方向的量。向量用一般用<strong>有向线段</strong>来表示。（可以看成是从某点指向另一个点的箭头）</p>
<p>向量的本质是：空间中存在一定长度和方向的箭头。例如三维空间中，向量可以用三维坐标来表示，也可以用长度和角度（也就是极坐标）来表示。</p>
<p><strong>因此，向量的加减法、内外积，其结果与坐标系的选取无关，不讨论坐标时也是可以计算的。</strong></p>
<h2 id="2-空间向量"><a href="#2-空间向量" class="headerlink" title="2 空间向量"></a>2 空间向量</h2><h3 id="2-1-标准正交基"><a href="#2-1-标准正交基" class="headerlink" title="2.1 标准正交基"></a>2.1 标准正交基</h3><p><strong>正交基</strong>：在n维欧氏空间中，由n个向量组成的正交向量组（向量长度不为1）称为正交基（orthogonal bases）。</p>
<p><strong>标准正交基</strong>：在n维欧氏空间中，由n个单位向量组成的正交基称为标准正交基（Orthonormal Bases）。</p>
<p>标准正交基需要两个要素：正交(orthogonal 垂直)和标准（normal 长度为1）。</p>
<p><strong>标准正交基与坐标系</strong>：单位向量互相垂直构成坐标系。</p>
<p>标准正交基 $\boldsymbol{Q}$ 的<strong>重要性质</strong>：</p>
<ul>
<li>性质一：$\boldsymbol{Q}^T\boldsymbol{Q}&#x3D;I$ </li>
<li>性质二：$\boldsymbol{Q}^T &#x3D; \boldsymbol{Q}^{-1}$</li>
</ul>
<p>在一个线性三维空间中，$(\boldsymbol{e}_1, \boldsymbol{e}_2, \boldsymbol{e}_3)$是该空间的一组标准正交基，那么任意向量  $\boldsymbol{a}$ 在这组基下就有一个坐标：</p>
<p><img src="/MD_IMG/2023-06-04-vector.assets/image-20230604134043425.png" alt="image-20230604134043425"></p>
<p>这里$(a_1, a_2, a_3)^T$ 称为  $\boldsymbol{a}$ 在此基下的坐标。</p>
<p>向量坐标的具体取值，一是和向量本身有关，二是和坐标系（基）的选取有关。坐标系通常由3个正交的坐标轴组成（尽管也可以有非正交的，但实际中很少见）。</p>
<p>坐标系有右手系和左手系，大部分3D程序库使用右手系（如OpenGL、3DMax等），也有部分库使用左手系（如Unity、Direct3D等）。</p>
<h3 id="2-2-向量的内积"><a href="#2-2-向量的内积" class="headerlink" title="2.2 向量的内积"></a>2.2 向量的内积</h3><p>对于向量 $\boldsymbol{a},\boldsymbol{b}\in\mathbb{R}^3$通常意义下的内积可以写成:</p>
<p><img src="/MD_IMG/2023-06-04-vector.assets/image-20230604150443001.png" alt="image-20230604150443001"></p>
<p>内积可以描述向量间的投影关系。</p>
<h3 id="2-3-向量的外积"><a href="#2-3-向量的外积" class="headerlink" title="2.3 向量的外积"></a>2.3 向量的外积</h3><p>对于向量 $\boldsymbol{a},\boldsymbol{b}\in\mathbb{R}^3$，外积公式如下（$(\boldsymbol{i}, \boldsymbol{j}, \boldsymbol{k})$是一组基）：</p>
<p><img src="/MD_IMG/2023-06-04-vector.assets/image-20230604150651679.png" alt="image-20230604150651679"></p>
<ul>
<li>外积的方向：垂直于这两个向量</li>
<li>外积的大小：$\vert\boldsymbol{a}\vert\vert\boldsymbol{b}\vert\sin\langle\boldsymbol{a},\boldsymbol{b}\rangle$，即：两个向量张成的四边形的有向面积。</li>
</ul>
<h2 id="3-一些特殊矩阵"><a href="#3-一些特殊矩阵" class="headerlink" title="3 一些特殊矩阵"></a>3 一些特殊矩阵</h2><h3 id="3-1-反对称矩阵"><a href="#3-1-反对称矩阵" class="headerlink" title="3.1 反对称矩阵"></a>3.1 反对称矩阵</h3><p>上述表述中，其实目的是把向量外积改写成矩阵和向量的乘法，而这是一个线性运算，这对我们是有帮助的。公式中引入了一个符号 ^，把向量 $\boldsymbol{a}$ 写成一个矩阵，事实上这个矩阵是一个<strong>反对称矩阵（Skew-symmetric Matrix）</strong>，可记为 $\boldsymbol{a}$^，符号 ^ 可记为反对称符号。</p>
<ul>
<li><p>向量 $\boldsymbol{a}$ 的反对称矩阵为：$\boldsymbol{a}$^</p>
<p><img src="/MD_IMG/2023-06-04-vector.assets/image-20230604162113634.png" alt="image-20230604162113634"></p>
</li>
<li><p>反对称符号是一个一一映射，任意向量都对应着唯一的一个反对称矩阵，反之亦然</p>
</li>
<li><p>记反对称矩阵 $\boldsymbol{a}$^ &#x3D; $\boldsymbol{A}$ ，则 $\boldsymbol{A}$ 满足 $\boldsymbol{A}^T&#x3D;-\boldsymbol{A}$ ，或记为： $\boldsymbol{A} &#x3D; -\boldsymbol{A}^T$.</p>
</li>
</ul>
<h3 id="3-2-正交矩阵"><a href="#3-2-正交矩阵" class="headerlink" title="3.2 正交矩阵"></a>3.2 正交矩阵</h3><p><code>&lt;TODO&gt;</code></p>
<h3 id="3-3-投影矩阵"><a href="#3-3-投影矩阵" class="headerlink" title="3.3 投影矩阵"></a>3.3 投影矩阵</h3><p><code>&lt;TODO&gt;</code></p>
<h2 id="4-SLAM数学基础-系列笔记"><a href="#4-SLAM数学基础-系列笔记" class="headerlink" title="4 SLAM数学基础*系列笔记"></a>4 SLAM数学基础*系列笔记</h2><ul>
<li><p><a href="https://miaomiao-w.github.io/2023/06/04/2023-06-04-vector/">SLAM数学基础（一）：向量与矩阵</a></p>
</li>
<li><p><a href="https://miaomiao-w.github.io/2023/06/05/2023-06-05-transform/">SLAM数学基础（二）：坐标转换</a></p>
</li>
<li><p><a href="https://miaomiao-w.github.io/2023/06/07/2023-06-07-probability/">SLAM数学基础（三）：概率论基础概念及相关公式</a></p>
</li>
<li><p><a href="https://miaomiao-w.github.io/2023/06/12/2023-06-12-MLE/">SLAM数学基础（四）：理解极大似然估计</a></p>
</li>
<li><p><a href="https://miaomiao-w.github.io/2023/06/19/2023-06-19-MAP/">SLAM数学基础（五）：理解最大后验概率估计</a></p>
</li>
<li><p><a href="https://miaomiao-w.github.io/2023/06/20/2023-06-20-LSM/">SLAM数学基础（六）：最小二乘法</a></p>
</li>
</ul>
<p align="center">---END---</p>

<hr>
<hr>
<blockquote>
<p>高翔、张涛等著《视觉SLAM十四讲》</p>
<p><a href="https://zhuanlan.zhihu.com/p/162732832">https://zhuanlan.zhihu.com/p/162732832</a> </p>
</blockquote>
]]></content>
      <categories>
        <category>SLAM</category>
        <category>SLAM数学基础</category>
      </categories>
      <tags>
        <tag>SLAM数学基础</tag>
        <tag>向量</tag>
        <tag>特殊矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title>SLAM数学基础（二）：坐标转换</title>
    <url>/2023/06/05/2023-06-05-transform/</url>
    <content><![CDATA[<h2 id="1-坐标转换矩阵"><a href="#1-坐标转换矩阵" class="headerlink" title="1 坐标转换矩阵"></a>1 坐标转换矩阵</h2><h3 id="1-1-旋转矩阵"><a href="#1-1-旋转矩阵" class="headerlink" title="1.1 旋转矩阵"></a>1.1 旋转矩阵</h3><p>旋转矩阵描述了一个旋转过程，可以用它来表示两个坐标系之间的旋转变换。也叫方向余弦矩阵。</p>
<p>相关性质：</p>
<ul>
<li>旋转矩阵 $\boldsymbol{R}$ 是一个正交矩阵，且行列式为1（反之，行列式为1的正交矩阵就是一个旋转矩阵）；</li>
<li>旋转矩阵 $\boldsymbol{R}$ 的转置（也即 $\boldsymbol{R}$ 的逆，因为对于正交矩阵， $\boldsymbol{R}^{-1}&#x3D;\boldsymbol{R}^T$ ）刻画了一个相反的旋转；</li>
<li>对加法不封闭，也就是说，对于任意两个旋转矩阵，按照矩阵加法定义相加，其结果不再是一个旋转矩阵；</li>
<li>乘法封闭；</li>
</ul>
<p>三维旋转矩阵构成了特殊正交群$\boldsymbol{SO(3)}$。后续详述。</p>
<h3 id="1-2-变换矩阵"><a href="#1-2-变换矩阵" class="headerlink" title="1.2 变换矩阵"></a>1.2 变换矩阵</h3><p>变换矩阵描述了一个欧式变换过程，包含旋转 $\boldsymbol{R}$ 和平移 $\boldsymbol{t}$ 。</p>
<p>为方便书写和计算，将一次欧式变换中的旋转 $\boldsymbol{R}$ 和平移 $\boldsymbol{t}$ 写成变换矩阵 $\boldsymbol{T}$ 形式，向量坐标写成齐次坐标形式。</p>
<img src="MD_IMG/2023-06-05-transform.assets/image-20230605152752584.png" alt="image-20230605152752584" style="zoom: 60%;" />

<p><strong>相关性质</strong>：</p>
<ul>
<li><p>变换矩阵 $\boldsymbol{T}$ 中的旋转矩阵 $\boldsymbol{R}$ 如前所述，其相关性质依然具备；</p>
</li>
<li><p>两次变换的叠加可表示为变换矩阵的乘法：</p>
</li>
</ul>
<p>$$<br>\boldsymbol{b}&#x3D;\boldsymbol{T}_1\boldsymbol{a}, \boldsymbol{c}&#x3D;\boldsymbol{T}_2\boldsymbol{b},\qquad\Rightarrow \qquad\boldsymbol{c}&#x3D;\boldsymbol{T}_2\boldsymbol{T}_1\boldsymbol{a},<br>$$</p>
<ul>
<li>对加法不封闭，也就是说，对于任意两个变换矩阵，按照矩阵加法定义相加，其结果不再是一个变换矩阵；</li>
<li>乘法封闭；</li>
</ul>
<p>三维空间下的变换矩阵构成了特殊欧式群$\boldsymbol{SE(3)}$。后续详述。</p>
<h2 id="2-李群与李代数"><a href="#2-李群与李代数" class="headerlink" title="2 李群与李代数"></a>2 李群与李代数</h2><h3 id="2-1-何为群？"><a href="#2-1-何为群？" class="headerlink" title="2.1 何为群？"></a>2.1 何为群？</h3><p><strong>群（Group）</strong>是<strong>一种集合</strong>加上<strong>一种运算</strong>的代数结构。</p>
<p>集合记为 $A$ ，运算记为 $\cdot{}$  ，那么群可以记作 $G&#x3D;(A,\ \dot{}\ )$ 。群要求集合 $A$ 和运算 $\cdot{}$  满足以下条件：</p>
<ul>
<li>封闭性： $\forall{}a_1,a_2\in{}A，\qquad\ a_1\cdot{}a_2\in{}A$</li>
<li>结合律： $\forall{}a_1,a_2,a_3\in{}A，\quad(a_1\cdot{}a_2)\cdot{}a_3 &#x3D;a_1\cdot{}\ (a_2\cdot{}a_3)$</li>
<li>幺元：     $\exists{}a_0\in{}A,\qquad{}s.t.;\forall{}a\in{}A,\qquad{}a_0\cdot{}a&#x3D;a\cdot{}a_0&#x3D;a$</li>
<li>逆：         $\forall{}a\in{}A,\qquad{}\exists{}a^{-1}\in{}A,\qquad{}s.t.;a\cdot{}a^{-1}&#x3D;a$</li>
</ul>
<p><strong>常见的群：</strong></p>
<ul>
<li>整数的加法                       $G&#x3D;(\mathbb{Z},+)$</li>
<li>去掉0后的有理数的乘法  $G&#x3D;(\mathbb{Q}\setminus0,\cdot{})$</li>
</ul>
<p><strong>常见的矩阵中的群：</strong></p>
<ul>
<li>一般线性群 $GL(n)$   指 $n\times{}n$ 的可逆矩阵，他们对矩阵乘法成群。</li>
<li>特殊正交群 $SO(n)$   也就是所谓的旋转矩阵群，其中$SO(2)$和$SO(3)$最为常见。</li>
<li>特殊欧式群 $SE(n)$   也就是前面提到的n维欧氏变换，如$SE(2)$和$SE(3)$ 。</li>
</ul>
<h3 id="2-2-何为李群"><a href="#2-2-何为李群" class="headerlink" title="2.2 何为李群"></a>2.2 何为李群</h3><p>李群是指具有连续（光滑）性质的群。</p>
<p>类似整数群 $\mathbb{Z}$ 那样离散的群没有连续性质，所以不是李群。</p>
<p>$SO(n)$ 和 $SE(n)$ 在实数空间上是连续的。我们能够直观地想象一个刚体能够连续地在空间中运动，所以它们都是李群。</p>
<h3 id="特殊正交群SO-3"><a href="#特殊正交群SO-3" class="headerlink" title="特殊正交群SO(3)"></a>特殊正交群SO(3)</h3><h3 id="特殊欧式群SE-3"><a href="#特殊欧式群SE-3" class="headerlink" title="特殊欧式群SE(3)"></a>特殊欧式群SE(3)</h3><h3 id="李代数的理解"><a href="#李代数的理解" class="headerlink" title="李代数的理解"></a>李代数的理解</h3><h2 id="3-补充知识点"><a href="#3-补充知识点" class="headerlink" title="3 补充知识点"></a>3 补充知识点</h2><p>记 $\ast{}$ 是非空集合 $S$ 上的二元运算：</p>
<ul>
<li><p><strong>幺元</strong>（也称单位元），当：</p>
<p> $\exists{}e\in{}S,\qquad{}s.t.;\forall{}x\in{}S,\qquad{}e\ast{}x&#x3D;x\ast{}e&#x3D;x$ ，那么就称 $e$ 是 $(S,*)$ 的幺元。</p>
<p>幺元具有不变性。</p>
<p>【举例】：</p>
<p>实数集合 $\mathbb{R}$ 上的加法运算中，0就是幺元；</p>
<p>实数集合 $\mathbb{R}$ 上的乘法运算中，1就是幺元。</p>
</li>
<li><p><strong>零元</strong>，当：</p>
<p>$\exists{}o\in{}S,\qquad{}s.t.;\forall{}x\in{}S,\qquad{}o\ast{}x&#x3D;x\ast{}o&#x3D;o$ ，那么就称 $o$ 是 $(S,*)$ 的零元。</p>
<p>【举例】实数乘法运算中，零元就是对任意元x，都有xa&#x3D;ax&#x3D;a，则a为零元，因此0即为零元。</p>
</li>
<li><p><strong>逆元</strong>，当：</p>
<p>$\forall{}a\in{}S,\qquad{}s.t.;\exists{}b\in{}S,\qquad{}a\ast{}b&#x3D;b\ast{}a&#x3D;e$ ，那么 $a$ 和 $b$ 互为逆元， $a$ 是 $b$ 的逆元，同时 $b$ 是 $a$ 的逆元。</p>
<p>【举例】实数乘法运算中，互为倒数的两个数互称逆元，2和1&#x2F;2互为逆元，1和其本身互为逆元;</p>
</li>
</ul>
<h2 id="4-SLAM数学基础-系列笔记s"><a href="#4-SLAM数学基础-系列笔记s" class="headerlink" title="4 SLAM数学基础*系列笔记s"></a>4 SLAM数学基础*系列笔记s</h2><ul>
<li><p><a href="https://miaomiao-w.github.io/2023/06/04/2023-06-04-vector/">SLAM数学基础（一）：向量与矩阵</a></p>
</li>
<li><p><a href="https://miaomiao-w.github.io/2023/06/05/2023-06-05-transform/">SLAM数学基础（二）：坐标转换</a></p>
</li>
<li><p><a href="https://miaomiao-w.github.io/2023/06/07/2023-06-07-probability/">SLAM数学基础（三）：概率论基础概念及相关公式</a></p>
</li>
<li><p><a href="https://miaomiao-w.github.io/2023/06/12/2023-06-12-MLE/">SLAM数学基础（四）：理解极大似然估计</a></p>
</li>
<li><p><a href="https://miaomiao-w.github.io/2023/06/19/2023-06-19-MAP/">SLAM数学基础（五）：理解最大后验概率估计</a></p>
</li>
<li><p><a href="https://miaomiao-w.github.io/2023/06/20/2023-06-20-LSM/">SLAM数学基础（六）：最小二乘法</a></p>
</li>
</ul>
<hr>
<blockquote>
<p>高翔、张涛等著《视觉SLAM十四讲》</p>
</blockquote>
]]></content>
      <categories>
        <category>SLAM</category>
        <category>SLAM数学基础</category>
      </categories>
      <tags>
        <tag>SLAM数学基础</tag>
        <tag>旋转矩阵</tag>
        <tag>变换矩阵</tag>
        <tag>李群</tag>
        <tag>李代数</tag>
        <tag>特殊正交群</tag>
        <tag>特殊欧式群</tag>
      </tags>
  </entry>
  <entry>
    <title>SLAM数学基础（三）：概率论基础概念及相关公式</title>
    <url>/2023/06/07/2023-06-07-probability/</url>
    <content><![CDATA[<h2 id="0-写在前面"><a href="#0-写在前面" class="headerlink" title="0 写在前面"></a>0 写在前面</h2><p>这不是一个深入浅出的入门讲解。</p>
<p>实在是因为本人苦于各种公式概念傻傻分不清楚，看了一遍一遍又边看边忘，想要时不时捋一捋。</p>
<h2 id="1-条件概率与独立性"><a href="#1-条件概率与独立性" class="headerlink" title="1 条件概率与独立性"></a>1 条件概率与独立性</h2><p><strong>条件概率</strong>：设有两个事件 $A, B$, 而 $P(B)\neq{} 0$. 则“在给定 $B$ 发生的情况下 $A$ 发生的条件概率”，记为 $P(A\vert{}B)$，定义为</p>
<p><img src="/MD_IMG/2023-06-07-probability.assets/image-20230607200205028.png" alt="image-20230607200205028"></p>
<p><strong>独立</strong>：两个事件 $A, B$ 若满足 $P(AB) &#x3D; P(A)P(B)$，则称 $A, B$ 独立。</p>
<p><img src="/MD_IMG/2023-06-07-probability.assets/image-20230607200231761.png" alt="image-20230607200231761"></p>
<p><strong>概率乘法定理</strong>： 若干个独立事件之积的概率，等于各事件的概率之乘积，即：</p>
<p><img src="/MD_IMG/2023-06-07-probability.assets/image-20230607200145134.png" alt="image-20230607200145134"></p>
<p><strong>全概率公式</strong>：</p>
<p><img src="/MD_IMG/2023-06-07-probability.assets/image-20230607200133322.png" alt="image-20230607200133322"></p>
<p><strong>贝叶斯公式</strong>：在全概率公式的假定下，有：</p>
<p><img src="/MD_IMG/2023-06-07-probability.assets/image-20230607200340184.png" alt="image-20230607200340184"></p>
<h2 id="2-概率分布"><a href="#2-概率分布" class="headerlink" title="2 概率分布"></a>2 概率分布</h2><h3 id="2-1-离散型随机变量"><a href="#2-1-离散型随机变量" class="headerlink" title="2.1 离散型随机变量"></a>2.1 离散型随机变量</h3><p>需要区分概率分布与分布函数。</p>
<p><strong>概率函数</strong>：</p>
<p>概率函数（离散型） 设 <strong>X</strong> 为离散型随机变量，其全部可能值为{<em>a<del>1</del> , a<del>2</del> ,</em> ···}，则其概率函数为：</p>
<p><img src="/MD_IMG/2023-06-07-probability.assets/image-20230607232744751.png" alt="image-20230607232744751"></p>
<p>上式称为随机变量 <strong>X</strong> 的<strong>概率分布</strong>。</p>
<p>概率分布，其实严格意义来说，应该叫做”<strong>离散型随机变量的值分布和概率分布</strong>“，强调分布。</p>
<p><strong>概率分布函数</strong>：</p>
<p><img src="/MD_IMG/2023-06-07-probability.assets/image-20230607233026312.png" alt="image-20230607233026312"></p>
<p><strong>伯努利分布（Bernoulli）</strong>：</p>
<p>伯努利分布是关于布尔变量 $x\in {0,1}$ 的概率分布，其连续参数 $p \in [0,1]$ 表示变量 $x&#x3D;1$ 的概率。</p>
<p>直观理解就是扔一次硬币，要不正面要不背面，如果是标准的硬币 p&#x3D;0.5 。</p>
<p>$$<br>P(x\vert{}p)&#x3D;p^x(1−p)^{1−x}\\<br>E(x)&#x3D;p,  var(x)&#x3D;p(1−p)<br>$$</p>
<p><strong>二项分布（Binomial）</strong>：</p>
<p>二项分布就是重复 <em>n</em> 次独立的伯努利试验。</p>
<p>若随机变量 X 的可能取值为0, 1, ···, n，且概率分布为</p>
<p><img src="/MD_IMG/2023-06-07-probability.assets/image-20230607234346009.png" alt="image-20230607234346009"></p>
<p>则称 X 服从二项分布，记为 <img src="/MD_IMG/2023-06-07-probability.assets/image-20230607234452556.png" alt="image-20230607234452556"></p>
<p>延展：泊松分布、超几何分布、负二项分布</p>
<h3 id="2-2-连续型随机变量"><a href="#2-2-连续型随机变量" class="headerlink" title="2.2 连续型随机变量"></a>2.2 连续型随机变量</h3><p><strong>概率密度函数</strong>与<strong>分布函数</strong>:</p>
<p>记分布函数为$F(x)$，记概率密度函数为$f(x)$，则有：</p>
<p><img src="/MD_IMG/2023-06-07-probability.assets/image-20230607235218630.png" alt="image-20230607235218630"></p>
<p>并且连续型概率密度函数有以下性质：</p>
<p>（1） <img src="/MD_IMG/2023-06-07-probability.assets/image-20230607235435509.png" alt="image-20230607235435509"></p>
<p>（2）<img src="/MD_IMG/2023-06-07-probability.assets/image-20230607235458144.png" alt="image-20230607235458144"></p>
<p>（3）对于任何常数 <em>a &lt; b</em>，有：</p>
<p><img src="/MD_IMG/2023-06-07-probability.assets/image-20230607235536259.png" alt="image-20230607235536259"></p>
<p><strong>正态分布</strong>：</p>
<p>正态随机变量 <strong>X</strong> ，记为 <img src="/MD_IMG/2023-06-07-probability.assets/image-20230607235838081.png" alt="image-20230607235838081"> </p>
<p>概率密度函数为：</p>
<p><img src="/MD_IMG/2023-06-07-probability.assets/image-20230607235919576.png" alt="image-20230607235919576"></p>
<p><strong>标准正态分布</strong>：</p>
<p>标准正态随机变量 <strong>X</strong> ，<img src="/MD_IMG/2023-06-07-probability.assets/image-20230608000039126.png" alt="image-20230608000039126"> </p>
<p>概率密度函数为：</p>
<p><img src="/MD_IMG/2023-06-07-probability.assets/image-20230608000117309.png" alt="image-20230608000117309"></p>
<p><img src="/MD_IMG/2023-06-07-probability.assets/image-20230608000205752.png" alt="image-20230608000205752"> </p>
<p>延展：指数分布、均匀分布</p>
<h2 id="3-多维随机变量"><a href="#3-多维随机变量" class="headerlink" title="3 多维随机变量"></a>3 多维随机变量</h2><h3 id="3-1-多维随机变量（随机向量）"><a href="#3-1-多维随机变量（随机向量）" class="headerlink" title="3.1 多维随机变量（随机向量）"></a>3.1 多维随机变量（随机向量）</h3><p><strong>n 维随机变</strong>：</p>
<p>一般地，设 $X &#x3D; (X_1, X_2,  ··· , X_n)$ 为一个n 维向量，其每个分量都是一维随机变量。</p>
<p><strong>【离散型】</strong>：</p>
<p>以 ${a_{i1},a_{i2},}$记 $X_i$ 的全部可能值 $(i&#x3D;1,2,…)$ ，则事件 ${X_1&#x3D;a_{1j_1},\ …\ ,X_n&#x3D;a_{1nj_n},}$ 的概率</p>
<p><img src="/MD_IMG/2023-06-07-probability.assets/image-20230608234746142.png" alt="image-20230608234746142"></p>
<p>称为随机向量  $X &#x3D; (X_1, X_2,  ··· , X_n)$ 的概率函数或概率分布。</p>
<p>概率函数满足的条件：</p>
<p>（1）<img src="/MD_IMG/2023-06-07-probability.assets/image-20230608234910580.png" alt="image-20230608234910580"></p>
<p>（2）<img src="/MD_IMG/2023-06-07-probability.assets/image-20230608234926926.png" alt="image-20230608234926926"></p>
<p><strong>【连续型】</strong>：（？？）</p>
<p>若$f(x_1,…,x_n)$ 是定义在 $\mathbb{R}^n$ 上的非负函数，使对 $\mathbb{R}^n$ 中的任意集合  $A$, 有</p>
<p><img src="/MD_IMG/2023-06-07-probability.assets/image-20230608233817923.png" alt="image-20230608233817923"></p>
<p>则称 $f$ 是 $X$ 的概率密度函数。</p>
<p><strong>边缘分布和边缘概率密度</strong>：</p>
<p> 边缘分布其实就是多维随机变量中的其中一维随机变量的分布函数。</p>
<p>对于连续型而言，边缘分布如下<br>$$<br>F_X(x)&#x3D;F(x,∞)&#x3D;∫^x_{−∞}[∫^∞_{−∞}f(x,y)dy]dx<br>$$<br>有了边缘分布函数，自然有边缘概率密度函数，根据定义及上面的式子有<br>$$<br>f_X(x)&#x3D;∫^∞_{−∞}f(x,y)dy<br>$$<br> y的情况也相同。</p>
<p>事实上，我们根据二维正态分布的概率密度，求出其边缘概率密度，发现边缘概率密度正是一维正态分布的的概率密度。</p>
<p><strong>有关注意事项</strong>：<br>(1) 定义一维或者多维连续型随机变量时，实质都在于有概率密度函数存在。（有密度函数的随机变量）<br>(2) 连续型随机变量不能简单定义为“其各分量都是一维连续型随机变量的那种随机向量”。</p>
<h3 id="3-2-二维正态分布"><a href="#3-2-二维正态分布" class="headerlink" title="3.2 二维正态分布"></a>3.2 二维正态分布</h3><p>概率密度函数：</p>
<p><img src="/MD_IMG/2023-06-07-probability.assets/image-20230608235056886.png" alt="image-20230608235056886"></p>
<p>其中：</p>
<p><img src="/MD_IMG/2023-06-07-probability.assets/image-20230608235128283.png" alt="image-20230608235128283"></p>
<p>记为：</p>
<p><img src="/MD_IMG/2023-06-07-probability.assets/image-20230608235219900.png" alt="image-20230608235219900"></p>
<h2 id="4-SLAM数学基础-系列笔记"><a href="#4-SLAM数学基础-系列笔记" class="headerlink" title="4 SLAM数学基础*系列笔记"></a>4 SLAM数学基础*系列笔记</h2><ul>
<li><p><a href="https://miaomiao-w.github.io/2023/06/04/2023-06-04-vector/">SLAM数学基础（一）：向量与矩阵</a></p>
</li>
<li><p><a href="https://miaomiao-w.github.io/2023/06/05/2023-06-05-transform/">SLAM数学基础（二）：坐标转换</a></p>
</li>
<li><p><a href="https://miaomiao-w.github.io/2023/06/07/2023-06-07-probability/">SLAM数学基础（三）：概率论基础概念及相关公式</a></p>
</li>
<li><p><a href="https://miaomiao-w.github.io/2023/06/12/2023-06-12-MLE/">SLAM数学基础（四）：理解极大似然估计</a></p>
</li>
<li><p><a href="https://miaomiao-w.github.io/2023/06/19/2023-06-19-MAP/">SLAM数学基础（五）：理解最大后验概率估计</a></p>
</li>
<li><p><a href="https://miaomiao-w.github.io/2023/06/20/2023-06-20-LSM/">SLAM数学基础（六）：最小二乘法</a></p>
</li>
</ul>
<p align="center">---END---</p>

<hr>
<hr>
<blockquote>
<p><a href="https://ustc-resource.github.io/USTC-Course/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/notes/index.html">USTC-Course: 中国科学技术大学课程资源</a></p>
<p>齐民友主编《概率论与数理统计》</p>
</blockquote>
]]></content>
      <categories>
        <category>SLAM</category>
        <category>SLAM数学基础</category>
      </categories>
      <tags>
        <tag>SLAM数学基础</tag>
        <tag>概率论</tag>
      </tags>
  </entry>
  <entry>
    <title>SLAM数学基础（四）：理解极大似然估计</title>
    <url>/2023/06/12/2023-06-12-MLE/</url>
    <content><![CDATA[<h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0 前言"></a>0 前言</h2><p>数理统计的基本问题是：根据样本所提供的信息，对总体的分布或者分布的数字特征等作出统计推断。</p>
<p>在数理统计中，极大似然估计法是点估计的一种方法，此外还有矩估计法。</p>
<p>极大似然原理：是人们从长期的实践经验中总结出来的，即，</p>
<p>一个已经发生的事件 A，如果我们推断出 <em>k</em> 导致 A 发生的概率最大，那么就推断导致事件 A 发生的原因是 <em>k</em> 。</p>
<p>这是极大似然估计法成立的基石。</p>
<h2 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1 问题描述"></a>1 问题描述</h2><p>有总体 $X$ ，它服从于一个参数为 $(\theta_1,\theta_2,\ …\ ,\theta_k)$ 的分布（该分布模型已知，但参数 $(\theta_1,\theta_2,\ …\ ,\theta_k)$ 未知，且正是我们的求解目标）。</p>
<p>从这个总体中，随机地且相互独立地抽取出样本集 $(X_1,X_2,\ …\ ,X_n)$ ，样本观测值为 $(x_1,x_2,\ …\ ,x_n)$ ，根据这个样本集信息来估计未知参数$(\theta_1,\theta_2,\ …\ ,\theta_k)$。</p>
<h2 id="2-分析与理解"><a href="#2-分析与理解" class="headerlink" title="2 分析与理解"></a>2 分析与理解</h2><p>既然这个总体的分布模型已知，只是参数未知，那么是可以写出这个模型的概率密度函数的，只不过这个函数中模型参数用符号 $\theta$ 表示，我们称之为总体 $X$ 的分布，记为 $F(x;\theta)$ ，当 $X$ 为连续型随机变量（为便于书写，此处暂不讨论离散型随机变量），其概率密度设为 $f(x;\theta)$ ，那么抽取到任意一个样本值为 $x_i$ 的样本 $X_i$ 的概率值为  $f(x_i;\theta)$ ，那么抽取到这个样本集的概率就是抽到每一个样本的概率值相乘（因为是相互独立），因此，记样本集 $(X_1,X_2,\ …\ ,X_n)$ 的联合概率为：</p>
<p>$$<br>L(\theta;x_1,\ …\ ,x_n)&#x3D;f(x_1;\theta)\ …\ f(x_n;\theta)&#x3D;\prod_{i&#x3D;1}^n{f(x_i;\theta)}<br>$$</p>
<p>注意，上式是关于 $\theta$ 的函数，其中的 $(x_1,x_2,\ …\ ,x_n)$ 是已知的，就是所抽取的样本集的观测值。这个函数反映的是在不同的参数取值 $θ$ 下，取得当前这个样本集的可能性，因此称为参数 $θ$ 相对于样本集的似然函数（likehood function）。记为 $L(θ)$ 。</p>
<p>回到问题描述中，我们现在已经抽到了这个样本，那为什么会抽到这个样本呢？凭什么就是它呢？从最容易接受的角度来描述，就是，因为抽到这个样本的概率大，所以我们抽到了它（总不至于，抽到这个样本的概率非常小，我就是一抽就抽到了它）。这里听起来有点拗口，停下来理解一下。其实这点就是极大似然估计法的基本思想。</p>
<p>当在随机的条件下获取了一个较大的样本，极大似然估计法的理论认为，在这个总体出现这个结果就是可能性最大的，that‘s why “极大似然”。</p>
<p>于是，就可以利用这点进行参数估计，将满足</p>
<p>$$<br>\hat\theta &#x3D; \arg \max(L(\theta))<br>$$</p>
<p>的 ${\theta}$ 取值 $\hat{\theta}$ 作为所求参数估计。</p>
<h2 id="3-一般求解步骤"><a href="#3-一般求解步骤" class="headerlink" title="3 一般求解步骤"></a>3 一般求解步骤</h2><p>（1）写出似然函数；</p>
<p>（2）对似然函数取对数，并整理；</p>
<p>（3）求导数，令导数为0，得到似然方程；</p>
<p>（4）解似然方程，得到的参数即为所求。</p>
<p>其中第二步取对数，是因为 $L(\theta)$ 表现为一些函数的连乘积，求 $\ln{}L(\theta)$ 会更加方便。</p>
<p><strong>Tips</strong>：其实要理解什么是极大似然估计是干什么的，到这里基本就可以了，后面是用更加严格的数学语言进行描述。</p>
<h2 id="4-数学定义"><a href="#4-数学定义" class="headerlink" title="4 数学定义"></a>4 数学定义</h2><h3 id="4-1-似然函数"><a href="#4-1-似然函数" class="headerlink" title="4.1 似然函数"></a>4.1 似然函数</h3><p><strong>似然函数定义</strong>：</p>
<p>设 $(X_1,X_2,\ …\ ,X_n)$ 是总体 $X$ 的样本，$(x_1,x_2,\ …\ ,x_n)$ 是样本观察值。称</p>
<p>$$<br>L(\theta)&#x3D;L(\theta;x_1,\ …\ ,x_n)&#x3D;<br>\begin{cases}<br>\prod_{i&#x3D;1}^n{p(x_i;\theta)} ,当X是离散型且其分布律为\ \  p(x;\theta)时;\\<br>\\<br>\prod_{i&#x3D;1}^n{f(x_i;\theta)} ,当X是连续型且其概率密度为f(x;\theta)时;<br>\end{cases}<br>$$</p>
<p>为似然函数。</p>
<p><strong>似然函数与概率密度函数</strong>：</p>
<p>（1）似然函数有其直观的意义。</p>
<p>取出样本$(X_1,X_2,\ …\ ,X_n)$ 可以理解为进行了n次随机试验，试验的结果为 $(x_1,x_2,\ …\ ,x_n)$ ，</p>
<p>当 $X$ 为离散型时，似然函数就是样本$(X_1,X_2,\ …\ ,X_n)$ 取值为 $(x_1,x_2,\ …\ ,x_n)$ 这一事件发生的概率；</p>
<p>当 $X$ 为连续型时，似然函数就是联合概率密度在 $(x_1,x_2,\ …\ ,x_n)$ 处的取值。</p>
<p>（2）似然函数与联合分布在形式上是一样的，但是含义不同。</p>
<p>似然函数是关于参数 ${\theta}$ 的函数；</p>
<p>联合分布是关于试验结果 $(x_1,x_2,\ …\ ,x_n)$ 的函数。</p>
<h3 id="4-2-极大似然估计值"><a href="#4-2-极大似然估计值" class="headerlink" title="4.2 极大似然估计值"></a>4.2 极大似然估计值</h3><p><strong>定义</strong>：</p>
<p>设 $L(\theta)&#x3D;L(\theta;x_1,\ …\ ,x_n)$ 是似然函数，若存在$\hat{\theta}&#x3D;\hat{\theta}(x_1,x_2,\ …\ ,x_n)$ 使得</p>
<p>$$<br>L(\hat{\theta})&#x3D;\max_{\theta\in\Theta}{L({\theta})}<br>$$</p>
<p>则称 $\hat{\theta}(x_1,x_2,\ …\ ,x_n)$ 是未知参数 ${\theta}$ 的极大似然估计值，</p>
<p>​        $\hat{\theta}(X_1,X_2,\ …\ ,X_n)$ 是未知参数 ${\theta}$ 的极大似然估计量。</p>
<p>极大似然估计值其实就是字面上的意思，似然函数取最大值时 ${\theta}$ 的值 $\hat{\theta}$  。这里望文生义是没有问题的。</p>
<h3 id="4-3-似然函数的重要性"><a href="#4-3-似然函数的重要性" class="headerlink" title="4.3  似然函数的重要性"></a>4.3  似然函数的重要性</h3><p>在统计学中，似然函数是表示参数取值给定一组观测数据的可能性大小的函数。它是参数的函数，给定某一组参数取值后，可以计算出这组参数下，观测数据出现的概率。</p>
<p>可以通过似然函数来选择最佳的参数估计值，通常使用最大似然估计法来进行参数估计。如前所述。</p>
<p>此外，在最大后验估计中，似然函数同样扮演着重要的角色，它是计算后验分布时的一部分。具体而言，在最大后验估计中，我们需要找到一个能够最大化后验分布的参数值，而后验分布可以通过似然函数和先验分布进行计算。</p>
<p>后验概率 $p(\theta\vert{}X)$ 通常由 $P(\theta\vert{}X)&#x3D;\frac{P(X\vert{}\theta)P(\theta)}{P(X)}$ 计算而得，其中 $P(X\vert{}\theta)$ 就是似然函数。</p>
<h2 id="5-EM算法"><a href="#5-EM算法" class="headerlink" title="5 EM算法"></a>5 EM算法</h2><p><code>&lt;TODO&gt;</code></p>
<h2 id="6-SLAM数学基础-系列笔记"><a href="#6-SLAM数学基础-系列笔记" class="headerlink" title="6 SLAM数学基础*系列笔记"></a>6 SLAM数学基础*系列笔记</h2><ul>
<li><p><a href="https://miaomiao-w.github.io/2023/06/04/2023-06-04-vector/">SLAM数学基础（一）：向量与矩阵</a></p>
</li>
<li><p><a href="https://miaomiao-w.github.io/2023/06/05/2023-06-05-transform/">SLAM数学基础（二）：坐标转换</a></p>
</li>
<li><p><a href="https://miaomiao-w.github.io/2023/06/07/2023-06-07-probability/">SLAM数学基础（三）：概率论基础概念及相关公式</a></p>
</li>
<li><p><a href="https://miaomiao-w.github.io/2023/06/12/2023-06-12-MLE/">SLAM数学基础（四）：理解极大似然估计</a></p>
</li>
<li><p><a href="https://miaomiao-w.github.io/2023/06/19/2023-06-19-MAP/">SLAM数学基础（五）：理解最大后验概率估计</a></p>
</li>
<li><p><a href="https://miaomiao-w.github.io/2023/06/20/2023-06-20-LSM/">SLAM数学基础（六）：最小二乘法</a></p>
</li>
</ul>
<hr>
<blockquote>
<p>齐民友主编《概率论和数理统计》</p>
</blockquote>
]]></content>
      <categories>
        <category>SLAM</category>
        <category>SLAM数学基础</category>
      </categories>
      <tags>
        <tag>SLAM数学基础</tag>
        <tag>极大似然估计</tag>
        <tag>MLE</tag>
      </tags>
  </entry>
  <entry>
    <title>SLAM数学基础（五）：理解最大后验概率估计</title>
    <url>/2023/06/19/2023-06-19-MAP/</url>
    <content><![CDATA[<h2 id="0-问题引出"><a href="#0-问题引出" class="headerlink" title="0 问题引出"></a>0 问题引出</h2><p>在前文《极大似然估计》中，基于极大似然原理，仅利用样本信息实现了对模型参数的估计。</p>
<p>极大似然原理的一个朴素认知，就是认为当前事件会发生，就是因为本身它发生的概率就比较大，那就干脆认为它发生的概率最大，基于这个前提来进行参数估计。</p>
<p>但是我们知道，一个随机事件的任何一种情况的出现都要考虑其概率，样本中出现频次最高的并不一定就是概率最大的那种情况，尤其是样本量较小的时候，这么这种情况下极大似然估计值是不是就不太可靠了呢？这个时候 ，如果有一些关于这个模型参数的初始信息（这个初始信息其实就是先验知识），当同时结合先验知识和样本信息来进行参数估计，是不是得到的结果的可信度更高一些？</p>
<h2 id="1-贝叶斯定理"><a href="#1-贝叶斯定理" class="headerlink" title="1 贝叶斯定理"></a>1 贝叶斯定理</h2><p>贝叶斯定理也叫贝叶斯公式、贝叶斯法则。</p>
<p>贝叶斯公式如下：</p>
<p>$$<br>P(A\vert{}B) &#x3D; \frac{P(B\vert{}A)\times P(A)}{P(B)}<br>$$</p>
<p>$P(A\vert{}B)$ 是在 $B$ 已经发生的条件下， $A$ 发生的概率；是一种条件概率。</p>
<p>$P(B\vert{}A)$ 是在 $A$ 已经发生的条件下， $B$ 发生的概率；也是条件概率。</p>
<p>$P(A)$ 是事件 $A$ 发生的概率。</p>
<p>$P(B)$ 是事件 $B$ 发生的概率。</p>
<p>上述公式的推导并不难，由</p>
<p>$$<br>P(A \cap B)&#x3D;P(B\vert{}A)\times P(A) \\<br>P(A \cap B)&#x3D;P(A\vert{}B)\times P(B)<br>$$</p>
<p>就可推出，但这不是重点，建立一种直观的理解才是更重要的。</p>
<hr>
<p>考虑并理解以下表述方式：</p>
<p>贝叶斯公式可以用来计算在给定某个观测结果的情况下，某个备选假设成立的概率。</p>
<p>设一个总体服从于某种分布，该分布模型参数为 $\theta$ ，$D$ 表示观测到的数据。根据贝叶斯公式，在给定数据 $D$ 下模型参数 $\theta$ 的概率分布：</p>
<p>$$<br>P(\theta\vert{}D) &#x3D; \frac{P(D\vert{}\theta)\times P(\theta)}{P(D)}<br>$$</p>
<p>其中，$P(\theta\vert{}D)$ 表示在已有数据 $D$ 的前提下，模型参数 $\theta$ 的概率分布，称为后验概率； $P(D\vert{}\theta)$ 是在模型参数为 $\theta$ 的前提下，观测到数据 $D$ 的概率（也称为似然函数，后面再讲）；</p>
<p> $P(\theta)$ 是模型参数 $\theta$ 的概率分布，称为先验概率；</p>
<p> $P(D)$ 表示观测到数据 $D$ 的概率。</p>
<p>后验概率是指在得到新的数据或信息后，重新计算某个事件发生的概率，即根据先前的经验和新的证据来更新我们的概率判断。</p>
<h2 id="2-贝叶斯公式中的似然函数理解"><a href="#2-贝叶斯公式中的似然函数理解" class="headerlink" title="2 贝叶斯公式中的似然函数理解"></a>2 贝叶斯公式中的似然函数理解</h2><p>上面提到， $P(D\vert{}\theta)$ 也称为似然函数，在数值上， $ P(D\vert{}\theta)&#x3D;L(\theta\vert{}D)$ ，</p>
<p>等式左边， $P(D\vert{}\theta)$ 其含义是在条件 $\theta$ 下观测到数据 $D$ 的概率，</p>
<p>等式右边， $L(\theta\vert{}D)$ 其含义是当已有观测数据 $D$ ，模型参数 $\theta$ 的似然。</p>
<p>为什么是这样呢？回顾似然函数的定义：</p>
<p><img src="/MD_IMG/2023-06-19-MAP.assets/image-20230620223556799.png" alt="image-20230620223556799"></p>
<p>所以事实上，我们这里说到的联合概率，以及前面的条件概率 $P(D\vert{}\theta)$ ，似然 $L(\theta\vert{}D)$ ，都是指同一个东西，形式上都是：</p>
<p>$$<br>p(x_1;\theta)p(x_2;\theta)…p(x_n;\theta)&#x3D;\prod_{i&#x3D;1}^n{p(x_i;\theta)}<br>$$</p>
<p>只不过，当模型参数 $\theta$ 已知时，它一般用来描述事件发生的概率，此时表述为条件概率或联合概率密度，着眼于“概率”；当模型参数 $\theta$ 未知时，这个式子一般就是用来估计模型参数 $\theta$ 的，此时被称为似然函数，是关于模型参数 $\theta$ 的函数，参数 $\theta$ 的估计方法一般有极大似然估计或最大后验估计（这两种方法也是频率学派和贝叶斯学派各自思想主张的具体体现之一，如果有时间再来总结对比吧）。</p>
<hr>
<p><strong>概率与似然的一种理解</strong>：</p>
<p>“概率”描述了给定模型参数后，描述结果的合理性，而不涉及任何观察到的数据。</p>
<p>“似然”描述了给定了特定观测值后，描述模型参数是否合理。</p>
<hr>
<p><strong>先验概率与后验概率的一种理解</strong>：</p>
<p>先验概率是 以全事件 $Ω$ 为背景下， $A$ 事件发生的概率， $P(A\vert{}Ω)$ 。</p>
<p>后验概率是 以新事件 $B$ 为背景下，$A$事件发生的概率， $P(A\vert{}B)$ 。</p>
<p>全事件一般是统计获得的，所以称为先验概率，是指没有实验前的概率，是普遍认可的先验知识（例如，硬币两面是均匀的）。</p>
<p>新事件一般是实验，如试验 $B$ ，现在是一个具体的情境了（例：我们现在手里有一个具体的硬币在做试验了），此时的事件背景从全事件变成了 $B$ ，该事件 $B$ 可能对 $A$ 的概率有影响，那么需要对$A$现在的概率进行一个修正，从 $P(A\vert{}Ω)$ 变成 $P(A\vert{}B)$ ，</p>
<p>所以称 $P(A\vert{}B)$ 为后验概率，也就是试验(事件$B$发生)后的概率，依据试验情况进行更新后的概率。</p>
<h2 id="3-最大后验概率MAP"><a href="#3-最大后验概率MAP" class="headerlink" title="3 最大后验概率MAP"></a>3 最大后验概率MAP</h2><p>讲到这里才真正说到最大后验概率估计，其实基本上已经说的差不多了。</p>
<p>最大后验概率（Maximum a posteriori probability，MAP）是一种用来描述随机事件的概率的统计方法。是贝叶斯推断中的一个重要方法，表示在给定观测值和先验信息时，得到最大后验概率的参数值。</p>
<p>在贝叶斯推断中，粗略地讲，对于一个已知的随机事件 $X$ 和其分布的先验知识 $P(\theta)$，其中 $\theta$ 是事件 $X$ 的未知参数，我们可以通过贝叶斯公式求出其后验概率 $P(\theta\vert{}X)$。具体而言，可以写作：</p>
<p>$$<br>P(\theta\vert{}X) &#x3D; \frac{P(X\vert{}\theta)P(\theta)}{P(X)}<br>$$</p>
<p> 其中，$P(X\vert{}\theta)$ 是已知参数 $\theta$ 下 $X$ 观测值的概率密度函数，称为似然函数；</p>
<p>$P(\theta)$ 是先验分布，即在进行观测前对未知参数 $\theta$ 的分布的了解；</p>
<p>$P(X)$ 是归一化常数，确保后验概率 $P(\theta\vert{}X)$ 的积分等于 $1$。</p>
<p>最大后验概率是指，在已知观测值 $X$ 和先验知识 $P(\theta)$ 的基础上，求出一个最有可能的参数 $\theta_{MAP}$，使得其后验概率 $P(\theta_{MAP}\vert{}X)$ 达到最大。即：</p>
<p>$$<br>\theta_{MAP} &#x3D; \underset{\theta}{\operatorname{argmax}} P(\theta\vert{}X)<br>$$</p>
<p>最大化后验概率求参数 $\theta$ 的估计值的方法，就是最大后验估计（MAP estimation）。</p>
<p>在一些数据较少且参数维度较高的问题中，最大后验估计算法相对于极大似然估计、普通最小二乘法等其他估计算法，能够通过先验概率信息有效避免过拟合和欠拟合等问题，提高模型的泛化能力。</p>
<p>当数据量或样本量非常大时，极大似然估计与最大后验估计是殊途同归的。</p>
<h2 id="4-SLAM数学基础-系列笔记"><a href="#4-SLAM数学基础-系列笔记" class="headerlink" title="4 SLAM数学基础*系列笔记"></a>4 SLAM数学基础*系列笔记</h2><ul>
<li><p><a href="https://miaomiao-w.github.io/2023/06/04/2023-06-04-vector/">SLAM数学基础（一）：向量与矩阵</a></p>
</li>
<li><p><a href="https://miaomiao-w.github.io/2023/06/05/2023-06-05-transform/">SLAM数学基础（二）：坐标转换</a></p>
</li>
<li><p><a href="https://miaomiao-w.github.io/2023/06/07/2023-06-07-probability/">SLAM数学基础（三）：概率论基础概念及相关公式</a></p>
</li>
<li><p><a href="https://miaomiao-w.github.io/2023/06/12/2023-06-12-MLE/">SLAM数学基础（四）：理解极大似然估计</a></p>
</li>
<li><p><a href="https://miaomiao-w.github.io/2023/06/19/2023-06-19-MAP/">SLAM数学基础（五）：理解最大后验概率估计</a></p>
</li>
<li><p><a href="https://miaomiao-w.github.io/2023/06/20/2023-06-20-LSM/">SLAM数学基础（六）：最小二乘法</a></p>
</li>
</ul>
<hr>
<blockquote>
<p>齐民友主编《概率论和数理统计》</p>
</blockquote>
]]></content>
      <categories>
        <category>SLAM</category>
        <category>SLAM数学基础</category>
      </categories>
      <tags>
        <tag>SLAM数学基础</tag>
        <tag>最大后验概率</tag>
        <tag>MAP</tag>
      </tags>
  </entry>
  <entry>
    <title>SLAM数学基础（六）：最小二乘法</title>
    <url>/2023/06/20/2023-06-20-LSM/</url>
    <content><![CDATA[<h2 id="1-最简单的最小二乘问题"><a href="#1-最简单的最小二乘问题" class="headerlink" title="1 最简单的最小二乘问题"></a>1 最简单的最小二乘问题</h2><p>先不考虑模型的适用场景，以及为什么要用这个方法，只从数学的角度，看这是一个什么问题。有如下数学模型：<br>$$<br>\min_{x}{F(x)}&#x3D;\frac{1}{2} \parallel{f(x)}\parallel_2^2<br>$$<br>最小二乘问题就是求满足上式的 $x$ 值。其中，自变量 $x\in\mathbb{R}^n$ ，$f$ 是任意标量非线性函数 $f(x):\mathbb{R}^n\mapsto\mathbb{R}$ 。注意这里的系数 $\frac{1}{2}$ 无关紧要，有没有都不会影响之后的结论。</p>
<p>拆解一下最小二乘，顾名思义，“二乘”就是指平方，“最小”指，要求的是函数 $F(x)$取最小值的时候 $x$ 的取值。当然，上面这个是最简单的一个最小二乘问题。</p>
<p>如果 $f$ 是个数学形式上很简单的函数，那么该问题可以用解析形式来求。令目标函数的导数为零： $\frac{dF}{dx}&#x3D;0$ ，然后求解 $x$ 的最优值，就和求二元函数的极值一样。解这个方程，就得到了导数为零处的极值。它们可能是极大、极小或鞍点处的值，只要逐个比较它们的函数值大小即可。</p>
<p>但是，这个方程是否容易求解呢？这取决于 $f$ 导函数的形式。如果 $f$ 为简单的线性函数，那么这个间题就是简单的线性最小二乘问题；但是有些导函数可能形式复杂，使得该方程可能不容易求解。求解这个方程需要我们知道关于目标函数的全局性质，而通常这是不大可能的。</p>
<p>对于不方便直接求解的最小二乘问题，可以用迭代的方式（到这里才是重点要了解学习的地方），从一个初始值出发，不断地更新当前的优化变量，使目标函数下降。对于最小二乘问题，有一阶和二阶梯度法（最速下降法、牛顿法），高斯牛顿法，列文伯格一马夸尔特法等，后两种实际应用较多，且高斯牛顿法最常用。</p>
<p>以上是最简单的模型情况，下面再来看最小二乘在一些实践中的应用。</p>
<h2 id="2-最小二乘的提出"><a href="#2-最小二乘的提出" class="headerlink" title="2 最小二乘的提出"></a>2 最小二乘的提出</h2><p>在生产实践中，经常会遇到利用一组观测数据来估计某些未知参数的问题。例如，一个做匀速直线运动的质点在时刻 $t$ 的位置是 $\hat{y}$ ，可以用如下的线性函数来描述：<br>$$<br>\hat{y}&#x3D;\hat{\alpha}+t\hat{\beta}<br>$$<br>式中， $\hat{\alpha}$ 是质点在$t&#x3D;0$时刻的初始位置， $\hat{\beta}$ 是平均速度，它们是待估计的未知参数，可见这类问题为线性参数的估计问题。对于这一问题，如果观测没有误差，则只要在两个不同时刻 $t_1$ 和 $t_2$ 观测出质点的相应位置 ${y_1}$ 和 ${y_2}$ ，由上述函数分别建立两个方程，就可以解出 $\hat{\alpha}$ 和 $\hat{\beta}$ 的值了。但是，实际上在观测时，考虑到观测值带有偶然误差，所以总是作多余观测。在这种情况下，为了求得 $\hat{\alpha}$ 和 $\hat{\beta}$ ，就需要在不同时刻 $t_1,t_2,\ …\ ,t_n$ 来测定其位置，得出一组观测值 $y_1,y_2,\ …\ ,y_n$ 这时，由上式可以得到：<br>$$<br>\delta{}_i&#x3D;\hat{\alpha}+t_i\ \hat{\beta}-y_i<br>$$<br>$\delta{}_i$ 为观测值 $y_i$ 与真值 $\hat{y_i}(&#x3D;\hat{\alpha}+t_i\ \hat{\beta})$ 的差值，即观测误差（或者成为残差）。由于观测误差的存在，由观测数据 $(t_i,y_i)$ 描绘不成直线，而有某些“摆动”。</p>
<p>这里就产生这样一个问题：用什么准则来对参数 $\hat{\alpha}$ 和 $\hat{\beta}$ 进行估计，从而使估计直线 $\hat{y}&#x3D;\hat{\alpha}+t\hat{\beta}$  “最佳”地拟合于各观测点？（哦对了，不要忘了，我们进行观测的目的是得到参数 $\hat{\alpha}$ 和 $\hat{\beta}$ 的估计值。）</p>
<p>这里的“最佳”一词可以有不同的理解。例如，</p>
<ul>
<li><p>可以认为：各观测点到直线最大距离取最小值时，直线是“最佳”的；</p>
</li>
<li><p>也可以认为，各观测点到直线的偏差的绝对值之和取最小值时，直线是“最佳”的，等等。</p>
</li>
</ul>
<p>在不同的“最佳要求下，可以求得相应问题中参数 $\hat{\alpha}$ 和 $\hat{\beta}$ 不同的估值。</p>
<p>早在19世纪，勒让德就认为依据“<strong>残差的平方和最小</strong>”估计出来的模型是最接近真实情形的。这也就是最小二乘原理，按照最小二乘原理的要求，认为“最佳”地拟合于各观测点的估计曲线，应使各观测点到该直线的偏差的平方和达到最小。</p>
<p>在众多的“最佳”中，为什么选择“<strong>残差的平方和最小</strong>”呢？这里暂且不表，后续再说。</p>
<h2 id="3-最小二乘的多维形式"><a href="#3-最小二乘的多维形式" class="headerlink" title="3 最小二乘的多维形式"></a>3 最小二乘的多维形式</h2><h2 id="4-最小二乘估计与极大似然估计"><a href="#4-最小二乘估计与极大似然估计" class="headerlink" title="4 最小二乘估计与极大似然估计"></a>4 最小二乘估计与极大似然估计</h2><h2 id="5-最小二乘问题的解法"><a href="#5-最小二乘问题的解法" class="headerlink" title="5 最小二乘问题的解法"></a>5 最小二乘问题的解法</h2><h2 id="6-SLAM数学基础-系列笔记"><a href="#6-SLAM数学基础-系列笔记" class="headerlink" title="6 SLAM数学基础*系列笔记"></a>6 SLAM数学基础*系列笔记</h2><ul>
<li><p><a href="https://miaomiao-w.github.io/2023/06/04/2023-06-04-vector/">SLAM数学基础（一）：向量与矩阵</a></p>
</li>
<li><p><a href="https://miaomiao-w.github.io/2023/06/05/2023-06-05-transform/">SLAM数学基础（二）：坐标转换</a></p>
</li>
<li><p><a href="https://miaomiao-w.github.io/2023/06/07/2023-06-07-probability/">SLAM数学基础（三）：概率论基础概念及相关公式</a></p>
</li>
<li><p><a href="https://miaomiao-w.github.io/2023/06/12/2023-06-12-MLE/">SLAM数学基础（四）：理解极大似然估计</a></p>
</li>
<li><p><a href="https://miaomiao-w.github.io/2023/06/19/2023-06-19-MAP/">SLAM数学基础（五）：理解最大后验概率估计</a></p>
</li>
<li><p><a href="https://miaomiao-w.github.io/2023/06/20/2023-06-20-LSM/">SLAM数学基础（六）：最小二乘法</a></p>
</li>
</ul>
<hr>
<p>当估计的变量是一个服从高斯分布的随机变量时，最小二乘可以由极大似然估计引出。此种情况下最小二乘估计和极大似然估计结果是一致的。</p>
<p>所以，最小二乘估计是极大似然估计的一种特例（？？？）。</p>
<p>服从高斯分布的随机变量由于服从正态分布有许多优雅的性质，因此广泛应用于工程实践中。不知道是不是错觉，极大似然估计多停留在数学层面，工程实践中最多的还是最小二乘估计。</p>
<hr>
<blockquote>
<p>高翔、张涛等著《视觉SLAM十四讲》</p>
<p>武汉大学测绘学院测量平差学科组编著《误差理论与测量平差基础》</p>
<p><a href="https://blog.csdn.net/MoreAction_/article/details/106443383"> 一文让你彻底搞懂最小二乘法—胤风的博客</a></p>
</blockquote>
]]></content>
      <categories>
        <category>SLAM</category>
        <category>SLAM数学基础</category>
      </categories>
      <tags>
        <tag>SLAM数学基础</tag>
        <tag>最小二乘法</tag>
        <tag>LSM</tag>
      </tags>
  </entry>
  <entry>
    <title>地面分割算法（一）：linefit_ground_segmentation</title>
    <url>/2023/06/23/2023-06-23-segmentation-01/</url>
    <content><![CDATA[<p>paper: <a href="https://ieeexplore.ieee.org/document/5548059/figures#figures">Fast segmentation of 3D point clouds for ground vehicles</a></p>
<p>Github: <a href="https://github.com/lorenwel/linefit_ground_segmentation">Github-lorenwel-linefit_ground_segmentation</a></p>
<h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1 简介"></a>1 简介</h2><p>这篇论文的算法是应用比较广泛的激光点云地面分割算法，在许多激光SLAM算法中都有引用。该论文方法效率高，且可以适用于具有一定坡度的地面。</p>
<p>算法中，将点云划分为多个扇区，一个扇区作为一个独立的处理单元。每个扇区再分成多个容器，每个容器取一个最低点，根据这些最低点拟合地面线，并以此为基础判断全部激光点是否为地面点，实现地面点云与非地面点云的分割。算法分为以下几个主要步骤：</p>
<ul>
<li><p>点云划分与映射</p>
</li>
<li><p>地面线段拟合</p>
</li>
<li><p>地面点云分割（地面点与非地面点判断）</p>
</li>
</ul>
<h2 id="2-点云结构化"><a href="#2-点云结构化" class="headerlink" title="2 点云结构化"></a>2 点云结构化</h2><p>点云结构化即：将一组无序的激光点云按照一定规则进行划分和映射，最终得到一组有序点云，也相当于是建立了索引，便于后续的算法处理。</p>
<ul>
<li>将激光点云按角度等间隔为 $N$ 个$Segment$（每个$Segment$为一个扇区），对于每个$Segment$ 按距离又等分$M$个$Bin$ （即容器），于是，每个点对应一个$(Segment,Bin)$；</li>
<li>对于每个三维点 $P(x,y,z)$ ，平面坐标用极坐标方式表示 $P(r,\theta,z)$ ，由于每个$Segment$ 内的点被认为角度一样，于是每个$Segment$ 内角度可以忽略，用二维点 $P(r,z)$ 表示，其中 $r&#x3D;\sqrt{x^2+y^2}$ ，相当于降维。</li>
<li>计算每个 $Bin$ 内的最低点 $MinZPoint(d,z)$ 。</li>
</ul>
<p><img src="/MD_IMG/2023-06-23-segmentation-01.assets/image-20230623225410411.png" alt="image-20230623225410411"></p>
<h2 id="3-地面线段拟合"><a href="#3-地面线段拟合" class="headerlink" title="3 地面线段拟合"></a>3 地面线段拟合</h2><h3 id="3-1-流程图"><a href="#3-1-流程图" class="headerlink" title="3.1 流程图"></a>3.1 流程图</h3><p>根据每个 $Bin$ 的最低点拟合地面线段 $GroundLine$ ，其论文理论部分相对简单，但代码逻辑相对复杂一些，原论文中的算法伪代码如下：</p>
<p><img src="/MD_IMG/2023-06-23-segmentation-01.assets/image-20230624172909256.png" alt="image-20230624172909256"></p>
<p>为更好地理解算法逻辑，下面为依据代码所做的流程图。提前进行如下说明：</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>binPoint</code></td>
<td>表示每个Bin中的最低点 <code>MinZPoint(d,z)</code></td>
</tr>
<tr>
<td><code>curBinPoint</code></td>
<td>当前循环中正在处理的 <code>binPoint</code></td>
</tr>
<tr>
<td><code>firstBinPoint</code></td>
<td>找到的第一个非空<code>bin</code>中的 <code>binPoint</code></td>
</tr>
<tr>
<td><code>非空bin</code></td>
<td>有激光点落入该<code>bin</code> 中则非空，<code>非空bin</code> 才有 <code>binPoint</code></td>
</tr>
<tr>
<td><code>linePoints</code></td>
<td>是一个<code>vector</code>，存储的是当前状态下，用于拟合局部地面线段的备选 <code>binPoint</code></td>
</tr>
<tr>
<td><code>lastBinPoint</code></td>
<td>上一个入选<code>linePoints</code>的 <code>binPoint</code>，<code>lastBinPoint=linePoints.back()</code></td>
</tr>
<tr>
<td><code>linePoints_size</code></td>
<td>上面<code>linePoints</code>这个<code>vector</code>的大小，也就是备选 <code>binPoint</code> 的点数量</td>
</tr>
<tr>
<td><code>localGroundLine</code></td>
<td>利用<code>linePoints</code>中的备选 <code>binPoint</code>拟合出的局部地面线段</td>
</tr>
<tr>
<td><code>groundLines</code></td>
<td>本算法的最终结果存储，是一个<code>vector</code>，里面元素为一个个线段，<br>每个线段实际保存两个点即可</td>
</tr>
</tbody></table>
<p>基于以上符号的含义来理解以下算法流程。为了便于理解整个算法，以下的判断条件多为简写，如<code>if curBinPoint valid</code>，<code>if localLine good</code> 等，具体的判断条件后文再具体分析，此处先提纲挈领地理解整个地面线段拟合的算法逻辑。</p>
<p>总的来说，需要带着两个问题：</p>
<ul>
<li>满足什么条件的点可以用来拟合地面线段？</li>
<li>什么条件下，地面线需要中断并重新开启一条线段（以符合不同坡度的地面情况）？</li>
</ul>
<p><img src="/MD_IMG/2023-06-23-segmentation-01.assets/image-20230624004950917.png" alt="image-20230624004950917"></p>
<p>以上流程中，同一颜色的框图代表相同或相近的含义：</p>
<ul>
<li>蓝：开始或转入一次循环；</li>
<li>橙：不同的判断条件；</li>
<li>绿：拟合地面线段（注意，并不是每次拟合的都是地面线段结果，效果不佳时要剔除相关点再拟合）；</li>
<li>黄：开始一条新的线。注意两种情况略有不同。<ul>
<li>第一种，有效点太少且又遇当前点为中断点，则删去前面的少量有效点，从中断点即当前点重新开始；</li>
<li>第二种实则又分为两种，一是前一个线段有效保存下来，二是前段依然有效点不够，但都是<code>lastBinPoint</code>作为中断点，与第一种情况<code>curBinPoint</code>为中断点略有不同（具体原因，前一个线段有效保存可以理解，但是前段有效点不够的情况似乎与第一种并无二致，原因暂未深究）；</li>
</ul>
</li>
<li>红：保存地面线段，注意，这个步骤<code>groundLines</code>存储的是我们本阶段的终极目标；</li>
<li>白：其他 less important 步骤，如<code>push、pop</code>等；</li>
<li>灰：算法起止。</li>
</ul>
<h3 id="3-2-判断条件"><a href="#3-2-判断条件" class="headerlink" title="3.2 判断条件"></a>3.2 判断条件</h3><ul>
<li><strong>if curBinPoint exists ?</strong> </li>
<li><strong>if linePoints_size ≥ n ？</strong></li>
</ul>
<p>这两个比较简单。</p>
<table>
<thead>
<tr>
<th>判断条件</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>if curBinPoint exists ? </code></td>
<td>有激光点落入该<code>bin</code> 中则非空，<br><code>非空bin</code> 有 <code>binPoint</code>，即<code>curBinPoint</code> 存在，反之不存在。</td>
</tr>
<tr>
<td><code>if linePoints_size ≥ n ?</code></td>
<td><code>linePoints</code>中的<code>binPoint</code>数量大于<code>n</code>表示满足判断条件。</td>
</tr>
</tbody></table>
<ul>
<li><strong>if curBinPoint valid ?</strong></li>
</ul>
<p>对应上述伪代码为第15行：</p>
<p><img src="/MD_IMG/2023-06-23-segmentation-01.assets/image-20230624200223441.png" alt="image-20230624200223441"></p>
<p>源代码为（linefit_ground_segmentation&#x2F;src&#x2F;segment.cc: Line 69）：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Not enough points. // Add point if valid.</span></span><br><span class="line"><span class="keyword">if</span> (cur_point.d - current_line_points.<span class="built_in">back</span>().d &lt; long_threshold_ &amp;&amp;</span><br><span class="line">    std::<span class="built_in">fabs</span>(current_line_points.<span class="built_in">back</span>().z - cur_ground_height) &lt; max_start_height_) &#123;</span><br><span class="line">    current_line_points.<span class="built_in">push_back</span>(cur_point);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有两个条件需要同时满足（用本文中定义的符号描述，<code>cur_point</code>即本文的<code>curBinPoint</code>，<code>current_line_points</code>即本文的<code>linePoints</code>，<code>current_line_points.back()</code>即本文的<code>lastBinPoint</code>），</p>
<p>① <code>curBinPoint.d - lastBinPoint.d &lt; long_threshold</code>，当前点和上一个入选<code>linePoints</code>的<code>binPoint</code>的平面距离<code>delta_d</code>小于预设值，此处原作者选取的阈值为 1.0 米；</p>
<p>② <code>lastBinPoint.height_from_ground &lt; max_start_height</code>，上一个备选<code>binPoint</code>的距地面高度小于预设值，此处原作者选取的阈值为 0.1 米；</p>
<ul>
<li><strong>if localLine good ?</strong></li>
</ul>
<p>对应上述伪代码为第6行：</p>
<p><img src="/MD_IMG/2023-06-23-segmentation-01.assets/image-20230624201240126.png" alt="image-20230624201240126"></p>
<p>源代码为（linefit_ground_segmentation&#x2F;src&#x2F;segment.cc: Line 47）：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (error &gt; max_error_ ||</span><br><span class="line">    std::<span class="built_in">fabs</span>(cur_line.first) &gt; max_slope_ ||</span><br><span class="line">    (current_line_points.<span class="built_in">size</span>() &gt; <span class="number">2</span> &amp;&amp; std::<span class="built_in">fabs</span>(cur_line.first) &lt; min_slope_) ||</span><br><span class="line">    is_long_line &amp;&amp; std::<span class="built_in">fabs</span>(expected_z - cur_point.z) &gt; max_long_height_) &#123;</span><br><span class="line">    current_line_points.<span class="built_in">pop_back</span>();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>源码中:</p>
<ul>
<li><p><code>error</code>：即<code>fiterror</code>，计算<code>linePoints</code>中所有点到拟合直线的距离并取其最大距离作为此拟合误差值；</p>
</li>
<li><p><code>cur_line.first</code>：拟合直线的斜率，也即拟合的地面坡度；</p>
</li>
<li><p><code>is_long_line</code>：<code>curBinPoint.d - lastBinPoint.d &gt; long_threshold</code>，当前点和上一个备选<code>binPoint</code>的平面距离大于预设值，则<code>is_long_line</code>为<code>true</code>；</p>
</li>
<li><p><code>expected_z</code>：当前点在上一个拟合地面线上的Z值</p>
</li>
</ul>
<p>以下四个条件满足任意一个，即表示刚刚拟合的地面线不是一个“好的直线”：</p>
<ul>
<li><p>① 拟合误差<code>error</code>大于设定阈值；</p>
</li>
<li><p>② 拟合的地面坡度<code>cur_line.first</code>大于设定阈值；</p>
</li>
<li><p>③ 拟合点数量<code>linePoints_size ≥3</code> 且 拟合的地面坡度<code>cur_line.first</code>大于设定阈值；</p>
</li>
<li><p>④ 同时满足<code>curBinPoint.d-lastBinPoint.d&gt;long_threshold</code>，<br>和<code>abs(expected_z-cur_point.z)&gt;max_long_height</code> 两个阈值条件。</p>
</li>
</ul>
<h2 id="4-地面点云分割"><a href="#4-地面点云分割" class="headerlink" title="4 地面点云分割"></a>4 地面点云分割</h2><p>简单来讲，就是计算激光点到当前及相邻的Segment中的拟合地面线段的投影误差，如果小于设置阈值，则认为是地面点，否则为非地面点。</p>
<p>此处关键在于找到正确的对应地面线段，要求激光点 $P(r,z)$ 的 $r$ 值在地面线段的起止点区间内 $(r_{min},r_{max})$ 方可认为是对应的地面线段，为了更有效地进行匹配，算法的匹配过程给这个起止区间加上了一个余量（或称为缓冲）<code>kMargin</code>，实际满足的条件为 $r\in(r_{min}-kMargin,\ \ r_{max}+kMargin)$。</p>
<p>具体步骤如下：</p>
<ul>
<li>① 在激光点所在的segment内，匹配地面线段，若匹配到合适的地面线段，则计算投影误差并返回；</li>
<li>② 若在①中没有成功匹配地面线段，则在邻域segment内，重复①步骤。其中，邻域segment定义为角度相差小于阈值<code>line_search_angle</code> 的左右相邻segment；</li>
<li>③ 无法匹配地面线段的激光点为非地面点；</li>
<li>④ 已经匹配地面线段的激光点，投影误差小于阈值 <code>max_dist_to_line</code> 的激光点为地面点，否则为非地面点。</li>
</ul>
<h2 id="5-算法参数设置"><a href="#5-算法参数设置" class="headerlink" title="5 算法参数设置"></a>5 算法参数设置</h2><p>前文中涉及到了不少的参数设置，主要是相关阈值，在这里总结一下。</p>
<p>在源代码中，参数配置文件为 linefit_ground_segmentation_ros&#x2F;launch&#x2F;segmentation_params.yaml</p>
<p>有以下参数：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">n_threads:</span> <span class="number">4</span>                <span class="comment"># number of threads to use.</span></span><br><span class="line"></span><br><span class="line"><span class="attr">r_min:</span> <span class="number">0.5</span>                  <span class="comment"># minimum point distance.</span></span><br><span class="line"><span class="attr">r_max:</span> <span class="number">50</span>                   <span class="comment"># maximum point distance.</span></span><br><span class="line"><span class="attr">n_bins:</span> <span class="number">120</span>                 <span class="comment"># number of radial bins.</span></span><br><span class="line"><span class="attr">n_segments:</span> <span class="number">360</span>             <span class="comment"># number of radial segments.</span></span><br><span class="line">     </span><br><span class="line"><span class="attr">max_dist_to_line:</span> <span class="number">0.05</span>      <span class="comment"># maximum vertical distance of </span></span><br><span class="line">                            <span class="comment"># point to line to be considered ground.</span></span><br><span class="line"></span><br><span class="line"><span class="attr">sensor_height:</span> <span class="number">1.8</span>          <span class="comment"># sensor height above ground.</span></span><br><span class="line"><span class="attr">min_slope:</span> <span class="number">0.0</span>              <span class="comment"># minimum slope of a ground line.</span></span><br><span class="line"><span class="attr">max_slope:</span> <span class="number">0.3</span>              <span class="comment"># maximum slope of a ground line.</span></span><br><span class="line"><span class="attr">max_fit_error:</span> <span class="number">0.05</span>         <span class="comment"># maximum error of a point during line fit.</span></span><br><span class="line"><span class="attr">long_threshold:</span> <span class="number">1.0</span>         <span class="comment"># distance between points after which </span></span><br><span class="line">                            <span class="comment"># they are considered far from each other.</span></span><br><span class="line"><span class="attr">max_long_height:</span> <span class="number">0.1</span>        <span class="comment"># maximum height change to previous point in long line.</span></span><br><span class="line"><span class="attr">max_start_height:</span> <span class="number">0.2</span>       <span class="comment"># maximum difference to estimated </span></span><br><span class="line">                            <span class="comment"># ground height to start a new line.</span></span><br><span class="line"><span class="attr">line_search_angle:</span> <span class="number">0.1</span>      <span class="comment"># how far to search in angular direction </span></span><br><span class="line">                            <span class="comment"># to find a line [unit: rad].</span></span><br><span class="line"></span><br><span class="line"><span class="attr">gravity_aligned_frame:</span> <span class="string">&quot;&quot;</span>   <span class="comment"># Frame which has its z axis aligned with gravity. </span></span><br><span class="line">                            <span class="comment"># (Sensor frame if empty.)</span></span><br><span class="line"></span><br><span class="line"><span class="attr">latch:</span> <span class="literal">false</span>                <span class="comment"># latch output topics or not</span></span><br><span class="line"><span class="attr">visualize:</span> <span class="literal">false</span>            <span class="comment"># visualize segmentation result - USE ONLY FOR DEBUGGING</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="6-效果展示"><a href="#6-效果展示" class="headerlink" title="6 效果展示"></a>6 效果展示</h2><p>论文中的效果展示：</p>
<p><img src="/MD_IMG/2023-06-23-segmentation-01.assets/image-20230701232839694.png" alt="image-20230701232839694"></p>
<h2 id="7-其他"><a href="#7-其他" class="headerlink" title="7 其他"></a>7 其他</h2><p>博文 <a href="https://blog.csdn.net/lovelyaiq/article/details/118826534">地面分割：Fast Segmentation of 3D Point Clouds for Ground Vehicles_TiRan_Yang的博客</a> 中举了一个实例，对代码进行了解读，可参看。</p>
]]></content>
      <categories>
        <category>激光雷达</category>
        <category>lidar算法</category>
        <category>地面分割</category>
      </categories>
      <tags>
        <tag>lidar</tag>
        <tag>地面分割</tag>
        <tag>segmentation</tag>
      </tags>
  </entry>
  <entry>
    <title>地面分割算法（二）：Ground_removal in LeGO-LOAM</title>
    <url>/2023/06/30/2023-06-30-segmentation-02/</url>
    <content><![CDATA[<p>paper: <a href="https://ieeexplore.ieee.org/abstract/document/8594299">LeGO-LOAM: Lightweight and Ground-Optimized Lidar Odometry and Mapping on Variable Terrain</a></p>
<p>Github: <a href="https://github.com/RobustFieldAutonomyLab/LeGO-LOAM">LeGO-LOAM - (RobustFieldAutonomyLab)</a></p>
<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h2><p>在LeGO-LOAM中，Ground removal 部分引用了上文 <a href="https://miaomiao-w.github.io/posts/segmentation-01/">地面分割算法（一）：linefit_ground_segmentation</a> 中介绍的论文 <a href="https://ieeexplore.ieee.org/document/5548059/figures#figures">Fast segmentation of 3D point clouds for ground vehicles</a>，但只是用了其中考虑地面坡度的思想，具体的代码实现有非常大的区别，包括点云的结构化方式和具体的地面滤除实施，并且代码非常的简化精炼。</p>
<p>Ground removal 部分的核心代码位于 LeGO-LOAM\LeGO-LOAM\src\imageProjection.cpp 文件中。 主要有两部分：点云结构化 <code>projectPointCloud()</code> 和地面滤除 <code>groundRemoval()</code>。</p>
<h2 id="2-点云结构化"><a href="#2-点云结构化" class="headerlink" title="2 点云结构化"></a>2 点云结构化</h2><ul>
<li><strong>主要原理</strong></li>
</ul>
<p>根据每个点的水平角度和垂直角度，再预先设置两个方向的角度分辨率，可计算得到每个点在这两个方向上的索引，将点云重新映射为基于图像的组织方式。</p>
<p>核心代码所在：<code>LeGO-LOAM\LeGO-LOAM\src\imageProjection.cpp\projectPointCloud()</code></p>
<ul>
<li><strong>角度分辨率的设置</strong></li>
</ul>
<p>可以参考激光雷达设备手册上的参数，一般都有关于激光点云在水平和垂直两个方向上的角度分辨率，可直接将其作为我们需要的阈值，这样可以最大程度保证每个点都能有效利用。事实上，也可以通过这两个阈值的设置（给定一个更大的值，如2倍于设备本身的角度分辨率），在点云映射的同时达到降采样的目的，这个可以根据实际需求。</p>
<p>源码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// location: LeGO-LOAM\LeGO-LOAM\include\utility.h</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">float</span> ang_res_x = <span class="number">0.2</span>; <span class="comment">// degree</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">float</span> ang_res_y = <span class="number">2.0</span>;</span><br></pre></td></tr></table></figure>



<ul>
<li><strong>计算水平角和垂直角</strong></li>
</ul>
<p>直接基于点坐标计算即可。垂直角$\theta_{v}$ ，水平角$\theta_{h}$ 。<br>$$<br>{\theta_{v}}<em>i&#x3D;\arctan{(\frac{z_i}{\sqrt{x_i^2+y_i^2}})} \\<br>{\theta</em>{h}}_i&#x3D;\arctan{(\frac{x_i}{y_i})}<br>$$<br>注：以上水平角公式是LeGO-LOAM中的计算方法，这个与坐标系定义和水平角起始方向选取有关。这里是以激光雷达坐标系的y轴正方向为0。这里用 $\arctan{(\frac{x_i}{y_i})}$ 还是 $\arctan{(\frac{y_i}{x_i})}$ 来计算依据实际需求而定。</p>
<p>源码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// location: LeGO-LOAM\LeGO-LOAM\src\imageProjection.cpp\projectPointCloud()</span></span><br><span class="line"><span class="type">float</span> distance = <span class="built_in">sqrt</span>(thisPoint.x * thisPoint.x + thisPoint.y * thisPoint.y);</span><br><span class="line">verticalAngle = <span class="built_in">atan2</span>(thisPoint.z, distance) * <span class="number">180</span> / M_PI;</span><br><span class="line">horizonAngle = <span class="built_in">atan2</span>(thisPoint.x, thisPoint.y) * <span class="number">180</span> / M_PI;</span><br></pre></td></tr></table></figure>




<ul>
<li><strong>计算激光点在图像上的坐标</strong></li>
</ul>
<p>这个坐标也就是上述【主要原理】中所讲的索引值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// location: LeGO-LOAM\LeGO-LOAM\src\imageProjection.cpp\projectPointCloud()</span></span><br><span class="line">rowIdn = (verticalAngle + ang_bottom) / ang_res_y;</span><br><span class="line">columnIdn = -<span class="built_in">round</span>((horizonAngle<span class="number">-90.0</span>)/ang_res_x) + Horizon_SCAN/<span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>这里的 <code>ang_bottom</code> 的引入和<code>-90.0</code>、<code>+ Horizon_SCAN/2</code> 都是为了将索引值转化为大于等于0的正整数，以符合图像中坐标的定义，也正是其所谓索引。</p>
<p>特别地，如果是机械雷达，<code>rowIdn</code> 其实就是 <code>ring</code>，可以免去这部分的计算，直接将 <code>ring</code> 值赋给 <code>rowIdn</code> 即可。</p>
<ul>
<li><strong>举例说明</strong></li>
</ul>
<p>以机械雷达为例：</p>
<p>图像行：每一线激光点就是图像中的一行点，并且图像中的任意一行的首尾其实也是相邻的，这点在后续的点云聚类中有体现（不在此文的地面点云分割范围）；</p>
<p>图像列：下图中两圈表示机械雷达的两线点云，红框中是同一个方向的分属于两线的两个点，映射到图像中就是同一列中相邻的两个像素点。</p>
<p><img src="/MD_IMG/2023-06-30-segmentation-02.assets/image-20230701184940252.png" alt="image-20230701184940252"></p>
<h2 id="3-地面滤除"><a href="#3-地面滤除" class="headerlink" title="3 地面滤除"></a>3 地面滤除</h2><p>LeGO-LOAM中地面滤除算法非常简单。</p>
<p>从靠近激光雷达的点开始判断。对于任意当前一点，再取出下一点（下一行中同一列的激光点），计算这两个点形成的坡度大小，再依据给定的坡度阈值（文中取值为10度），判断其是否为地面点。</p>
<p>激光点是有可能有无效点的，没有收到回波的点一般存为Nan点，那么如果当前或者下一点是无效点，这个坡度值就没办法计算了，那么当前点就标记为 -1；</p>
<p>对于正常的两个点，如果计算坡度小于阈值，则两点同为地面点，标记为 1；</p>
<p>如果计算坡度大于阈值，则两点均为非地面点，标记为 0。</p>
<p>结束了，就这么简单。</p>
<p>可能会有人要问了，那如果是一个障碍物目标，它的上表面比较平整，不是就被误判为地面点了吗？</p>
<p>是这样，肯定是有这个的概率的。但是本文的地面分割是为了更好地做后续的特征匹配的工作，这里不是为了做障碍物识别，所以这一点误判影响并不大；并且，这些误判点不一定会被识别为特征点，可以说又降低了其影响；再者，论文中的实验大多是周围是植被的环境，且安装位置也比较低，不太容易出现上面所说的这种情况。</p>
<p>所以要注意，如果是用于自动驾驶的避障中，可能要多关注这个问题。特别是安装在巴士顶部的激光雷达，能够看到前车的顶部，特别是挂车后的拖挂平板这种，可能就漏掉了。这是需要注意的。</p>
<h2 id="4-点云的代码结构"><a href="#4-点云的代码结构" class="headerlink" title="4 点云的代码结构"></a>4 点云的代码结构</h2><p>这部分的代码组织个人感觉还是很好的，可以借鉴参考。</p>
<p>首先根据两个方向的视场角和角度分辨率，可以得到图像的大小。这个size一般事先计算当做参数输入。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// location: LeGO-LOAM\LeGO-LOAM\include\utility.h</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">int</span> N_SCAN = <span class="number">16</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">int</span> Horizon_SCAN = <span class="number">1800</span>;</span><br></pre></td></tr></table></figure>

<p>这里用了三个变量来存储结构化的点云，rangeMat，groundMat，fullCloud</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cv::Mat rangeMat; <span class="comment">// range matrix for range image</span></span><br><span class="line">cv::Mat groundMat; <span class="comment">// ground matrix for ground cloud marking</span></span><br><span class="line">rangeMat  = cv::<span class="built_in">Mat</span>(N_SCAN, Horizon_SCAN, CV_32F, cv::Scalar::<span class="built_in">all</span>(FLT_MAX));</span><br><span class="line">groundMat = cv::<span class="built_in">Mat</span>(N_SCAN, Horizon_SCAN, CV_8S, cv::Scalar::<span class="built_in">all</span>(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// projected velodyne raw cloud, but saved in the form of 1-D matrix</span></span><br><span class="line">pcl::PointCloud&lt;PointType&gt;::Ptr fullCloud; </span><br><span class="line">fullCloud-&gt;points.<span class="built_in">resize</span>(N_SCAN*Horizon_SCAN);</span><br><span class="line">std::<span class="built_in">fill</span>(fullCloud-&gt;points.<span class="built_in">begin</span>(), fullCloud-&gt;points.<span class="built_in">end</span>(), nanPoint);</span><br></pre></td></tr></table></figure>

<p><code>rangeMat、groundMat</code> 为图像形式，分别存储距离值和是否地面点的标签。<code>fullCloud</code> 为 <code>pcl</code> 的点云格式，并且与图像格式一一对应，<code>fullCloud</code> 中 <code>index</code> 为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// rowIdn       : point index of image row</span></span><br><span class="line"><span class="comment">/// columnIdn    : point index of image column</span></span><br><span class="line"><span class="comment">/// Horizon_SCAN : size of each image row</span></span><br><span class="line">index = columnIdn  + rowIdn * Horizon_SCAN;</span><br></pre></td></tr></table></figure>

<p>如此对应，便于点云组织以及后续算法调用。</p>
<p>以下是论文中特征提取的过程。</p>
<p><img src="/MD_IMG/2023-06-30-segmentation-02.assets/image-20230701232141293.png" alt="image-20230701232141293"></p>
]]></content>
      <categories>
        <category>激光雷达</category>
        <category>lidar算法</category>
        <category>地面分割</category>
      </categories>
      <tags>
        <tag>lidar</tag>
        <tag>地面分割</tag>
        <tag>segmentation</tag>
      </tags>
  </entry>
  <entry>
    <title>LIOSAM 工程是怎么跑起来的</title>
    <url>/2023/07/06/2023-07-06-liosam-mapOpt-01/</url>
    <content><![CDATA[<p>liosam 工程是怎么跑起来的</p>
<p>LIOSAM 的中 Topic 与 node 的关联图，咋一看非常之多，十分骇人，但是从捋出重要 Topic 之后，就简练的多了，关注以下这些：</p>
<p>&#x2F;lio_sam&#x2F;mapping&#x2F;odometry_incremental：节点 </p>
<p>rosgraph-more-topics</p>
<p>rosgraph-less-topics</p>
<h2 id="后端优化中雷达位姿的初值获取"><a href="#后端优化中雷达位姿的初值获取" class="headerlink" title="后端优化中雷达位姿的初值获取"></a>后端优化中雷达位姿的初值获取</h2><p>LIOSAM 中的 lidar_link 其实也就是base_link，它与机器人场景中的机器人、自动驾驶场景的车辆是类似的。</p>
<p>在优化问题中，一个好的初值是非常重要的。LIOSAM在启动过程中，不同的状态下位姿初值获取选用了不同的方案。</p>
<h3 id="第一帧"><a href="#第一帧" class="headerlink" title="第一帧"></a>第一帧</h3><p>当接收到第一帧点云，将IMU原始数据中的角度值作为初始姿态，位置直接用（0，0，0）。位姿初始化在文件 <code>mapOptmization.cpp</code> 中， ， 代码如下，</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//// @file： LIO-SAM/src/mapOptmization.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">updateInitialGuess</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// save current transformation before any processing</span></span><br><span class="line">    incrementalOdometryAffineFront = <span class="built_in">trans2Affine3f</span>(transformTobeMapped);</span><br><span class="line">    <span class="type">static</span> Eigen::Affine3f lastImuTransformation;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// initialization</span></span><br><span class="line">    <span class="keyword">if</span> (cloudKeyPoses3D-&gt;points.<span class="built_in">empty</span>())<span class="comment">// lidar trajectory</span></span><br><span class="line">    &#123;</span><br><span class="line">        transformTobeMapped[<span class="number">0</span>] = cloudInfo.imuRollInit;<span class="comment">// 时间早于 point_cloud, 且最接近一帧的 imu 数据中的RPY</span></span><br><span class="line">        transformTobeMapped[<span class="number">1</span>] = cloudInfo.imuPitchInit;</span><br><span class="line">        transformTobeMapped[<span class="number">2</span>] = cloudInfo.imuYawInit;</span><br><span class="line">        <span class="keyword">if</span> (!useImuHeadingInitialization)</span><br><span class="line">            transformTobeMapped[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        lastImuTransformation = pcl::<span class="built_in">getTransformation</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, cloudInfo.imuRollInit, cloudInfo.imuPitchInit, cloudInfo.imuYawInit); <span class="comment">// save imu before return;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// use imu pre-integration estimation for pose guess</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// use imu incremental estimation for pose guess (only rotation)</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述 updateInitialGuess() 函数中：</p>
<p>位姿保存在变量 transformTobeMapped[] 中，且只对角度赋值，位置值保留变量的初始化值；代码如下；</p>
<p>角度的赋初值：cloudInfo.imuRollInit &#x2F; imuPitchInit &#x2F; imuYawInit 的获取在文件 imageProjection.cpp 中，存于消息 cloud_info 中与其他消息一并发布；代码如下；</p>
<p>另还有两个参数 incrementalOdometryAffineFront 和 lastImuTransformation，lastImuTransformation 用于下一帧的雷达初始化（详见下一小节）；incrementalOdometryAffineFront在后续生成平滑的 lidar Odometry 中有应用。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//// @file： LIO-SAM/src/mapOptmization.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">allocateMemory</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; ++i)&#123;</span><br><span class="line">        transformTobeMapped[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//// @file： LIO-SAM/src/imageProjection.cpp    </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">imuDeskewInfo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...        </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="type">int</span>)imuQueue.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        sensor_msgs::Imu thisImuMsg = imuQueue[i];</span><br><span class="line">        <span class="type">double</span> currentImuTime = thisImuMsg.header.stamp.<span class="built_in">toSec</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// get roll, pitch, and yaw estimation for this scan</span></span><br><span class="line">        <span class="comment">// 持续更新 rpy 直到 IMU 时间为小于雷达时间且相距最近</span></span><br><span class="line">        <span class="keyword">if</span> (currentImuTime &lt;= timeScanCur)</span><br><span class="line">            <span class="built_in">imuRPY2rosRPY</span>(&amp;thisImuMsg, &amp;cloudInfo.imuRollInit, &amp;cloudInfo.imuPitchInit, &amp;cloudInfo.imuYawInit);</span><br><span class="line">        <span class="keyword">if</span> (currentImuTime &gt; timeScanEnd + <span class="number">0.05</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上述 imuDeskewInfo() 中的 imuRPY2rosRPY() 函数（line 23）定义在 utility.h 中，函数功能简单，只将 IMU_raw 中的 orientation 作格式转换，不多赘述。</p>
<h3 id="第二帧"><a href="#第二帧" class="headerlink" title="第二帧"></a>第二帧</h3><p>收到第二帧点云后，判断其不满足时间间隔阈值，直接返回。</p>
<h3 id="第三帧"><a href="#第三帧" class="headerlink" title="第三帧"></a>第三帧</h3><p>收到点云后，进入函数 updateInitialGuess() 中，不是第一帧后只需要关注后面的两个判断条件，<code>cloudInfo.imuAvailable, cloudInfo.odomAvailable</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//// @file： LIO-SAM/src/mapOptmization.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">updateInitialGuess</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// save current transformation before any processing</span></span><br><span class="line">    incrementalOdometryAffineFront = <span class="built_in">trans2Affine3f</span>(transformTobeMapped);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// initialization</span></span><br><span class="line">    <span class="keyword">if</span> (cloudKeyPoses3D-&gt;points.<span class="built_in">empty</span>())&#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// use imu pre-integration estimation for pose guess</span></span><br><span class="line">    <span class="keyword">if</span> (cloudInfo.odomAvailable == <span class="literal">true</span>)&#123;...&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// use imu incremental estimation for pose guess (only rotation)</span></span><br><span class="line">    <span class="keyword">if</span> (cloudInfo.imuAvailable == <span class="literal">true</span>)&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>imuAvailable,odomAvailable </code> 这两个参数同样来自于文件 <code>imageProjection.cpp  </code>  ：</p>
<ul>
<li><p>参数 <code>cloudInfo.imuAvailable</code> 是指是否收到用于畸变纠正的 <code>IMU</code> 原始数据，是一开始就有的；</p>
</li>
<li><p>参数 <code>cloudInfo.odomAvailable</code> 是指是否收到用于畸变纠正的 <code>IMU odometry</code> ，而这个 Topic 是在收到节点 <code>mapOptmization</code> 发出的 <code>lidar odometry</code> 后再下一帧处理所得（收到第一帧需要初始化）；</p>
</li>
</ul>
<p>因此进入第三个case，<code>if (cloudInfo.imuAvailable == true)&#123;...&#125;</code> 。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//// @file： LIO-SAM/src/mapOptmization.cpp</span></span><br><span class="line"><span class="type">void</span> updateInitialGue当前帧的位姿初值 `transFinal=transTobe * transIncre` <span class="built_in">ss</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// save current transformation before any processing</span></span><br><span class="line">    incrementalOdometryAffineFront = <span class="built_in">trans2Affine3f</span>(transformTobeMapped);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// initialization</span></span><br><span class="line">    ...    </span><br><span class="line">    <span class="comment">// use imu pre-integration estimation for pose guess</span></span><br><span class="line">    ...    </span><br><span class="line">    <span class="comment">// use imu incremental estimation for pose guess (only rotation)</span></span><br><span class="line">    <span class="keyword">if</span> (cloudInfo.imuAvailable == <span class="literal">true</span>)&#123;        </span><br><span class="line">        <span class="built_in">ROS_WARN</span>(<span class="string">&quot;Guess init, imuAvailable&quot;</span>);</span><br><span class="line">        Eigen::Affine3f transBack = pcl::<span class="built_in">getTransformation</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, cloudInfo.imuRollInit, cloudInfo.imuPitchInit, cloudInfo.imuYawInit);</span><br><span class="line">        Eigen::Affine3f transIncre = lastImuTransformation.<span class="built_in">inverse</span>() * transBack;</span><br><span class="line"></span><br><span class="line">        Eigen::Affine3f transTobe = <span class="built_in">trans2Affine3f</span>(transformTobeMapped);</span><br><span class="line">        Eigen::Affine3f transFinal = transTobe * transIncre;</span><br><span class="line">        pcl::<span class="built_in">getTranslationAndEulerAngles</span>(transFinal, transformTobeMapped[<span class="number">3</span>], transformTobeMapped[<span class="number">4</span>], transformTobeMapped[<span class="number">5</span>], </span><br><span class="line">                                                      transformTobeMapped[<span class="number">0</span>], transformTobeMapped[<span class="number">1</span>], transformTobeMapped[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">        lastImuTransformation = pcl::<span class="built_in">getTransformation</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, cloudInfo.imuRollInit, cloudInfo.imuPitchInit, cloudInfo.imuYawInit); <span class="comment">// save imu before return;</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这一段代码的逻辑是，通过结合上一帧的雷达位姿和两帧雷达位姿的增量来计算而得，获取当前帧的雷达位姿。</p>
<p>上一帧的雷达位姿初值 $T_{last_init}$ ：上一帧处理过程中存于变量 <code>lastImuTransformation</code> ；</p>
<p>上一帧雷达位姿优化值 $T_{last_opt}$ ：上一帧的优化位姿，存于 <code>transformTobeMapped[]</code> ，格式转换得到 <code>transTobe</code> ；</p>
<p>当前帧雷达位姿临时值 $T_{cur_temp}$ ：当前帧从 <code>IMU</code>原始数据中获取的位姿，存于 <code>transBack</code> ；</p>
<p>当前帧的雷达位姿初值 $T_{cur_init}$ ：也就是当前函数的待求值，前帧的位姿初值 <code>transFinal=transTobe * transIncre</code> &gt;。</p>
<p>两帧之间的位姿增量 $T_{between}$ ：上一帧位姿初值 $T_{last-init}$ 和当前帧雷达位姿临时值 $T_{cur_temp}$ 之间的增量（<code>transIncre</code>）；</p>
<p>用公式表示为：<br>$$<br>T_{between}&#x3D;T_{last_init}^{-1}T_{cur_temp}\T_{cur_init}&#x3D;T_{last_opt}T_{between}<br>$$<br>得到当前帧位姿初值后，再度存于 <code>transformTobeMapped[]</code> 中对其进行更新，这个参数非常重要的。</p>
<p>并同时更新<code>lastImuTransformation</code> 用于下一帧的处理。</p>
<p>注1：前面的【当前帧雷达位姿临时值】是笔者自己起的一个名字，为区别于用于后端优化的初值，而用了临时值的说法。</p>
<p>注2：这部分应用到有关矩阵右乘的知识点，主要多加注意，可参考这个问题 <a href="https://www.zhihu.com/question/263660493">矩阵左乘，右乘到底是什么意思？</a>中 <a href="https://www.zhihu.com/people/yan-fei-can-yue-tian-50">糖糖不是堂</a> 的回答。</p>
<h3 id="第四帧"><a href="#第四帧" class="headerlink" title="第四帧"></a>第四帧</h3><p>同第二帧情形，不满足时间间隔阈值，直接返回。</p>
<h3 id="第五帧"><a href="#第五帧" class="headerlink" title="第五帧"></a>第五帧</h3><p>到此时，</p>
<h2 id="雷达里程计的最高频率"><a href="#雷达里程计的最高频率" class="headerlink" title="雷达里程计的最高频率"></a>雷达里程计的最高频率</h2><p>雷达里程计并不是对每一帧点云都进行处理，这里有一个时间阈值的判断。</p>
<p><a href="">《后端优化中 雷达 位姿的初始化》</a>中所说的第二帧，是指满足时间间隔要求的第二帧，实为第三帧，收到的第二帧点云与第一帧</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//// @file： LIO-SAM/src/mapOptmization.cpp</span></span><br><span class="line"><span class="keyword">if</span> (timeLaserInfoCur - timeLastProcessing &gt;= mappingProcessInterval)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>mappingProcessInterval</code>的默认参数是0.15s，所以在默认参数下，雷达里程计不会超过1&#x2F;0.15Hz</p>
<p>参数配置文件： <code>LIO-SAM/config/params.yaml</code></p>
<h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><ul>
<li><p>每个 Topic 具体发布的数据什么含义</p>
</li>
<li><p>mapOpt 中的lio_sam&#x2F;mapping&#x2F;odometry 与 lio_sam&#x2F;mapping&#x2F;odometry_incremental有什么区别与联系?</p>
</li>
</ul>
<p><a href="https://github.com/TixiaoShan/LIO-SAM/issues/92">https://github.com/TixiaoShan/LIO-SAM/issues/92</a></p>
<ul>
<li><p>odometry&#x2F;imu 与 odometry&#x2F;imu_incremental</p>
<p>odometry&#x2F;imu_incremental，在imagerojection发布</p>
<p>odometry&#x2F;imu，在transformusion中，</p>
</li>
<li><p>transformTobeMapped 的初始化与优化历程</p>
</li>
<li><p>gtsam 中 的先验因子和 Values 有什么区别</p>
</li>
<li><p>imgProject 中用于畸变纠正的 IMU 数据 Odom 数据</p>
<p>Odom 数据 为什么用 IMU 里程计，而不用 lidar Odom？因为后者滞后</p>
<p>roll，pitch，yaw 的纠正为什么用原始IMU，而不用  IMU 里程计 中的orientation？ 尚不清楚。</p>
</li>
<li><p>addOdomFactor() 为何首帧的噪声模型参数的yaw为 PI*PI？</p>
</li>
</ul>
]]></content>
      <categories>
        <category>SLAM</category>
        <category>LIOSAM</category>
      </categories>
      <tags>
        <tag>SLAM</tag>
        <tag>LIOSAM</tag>
        <tag>后端优化</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2023/07/09/liosam%20%E5%B7%A5%E7%A8%8B%E6%98%AF%E6%80%8E%E4%B9%88%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/</url>
    <content><![CDATA[<p>liosam 工程是怎么跑起来的</p>
<p>LIOSAM 的中 Topic 与 node 的关联图，咋一看非常之多，十分骇人，但是从捋出重要 Topic 之后，就简练的多了，关注以下这些：</p>
<p>&#x2F;lio_sam&#x2F;mapping&#x2F;odometry_incremental：节点 </p>
<p>rosgraph-more-topics</p>
<p>rosgraph-less-topics</p>
<h2 id="后端优化中雷达位姿的初值获取"><a href="#后端优化中雷达位姿的初值获取" class="headerlink" title="后端优化中雷达位姿的初值获取"></a>后端优化中雷达位姿的初值获取</h2><p>LIOSAM 中的 lidar_link 其实也就是base_link，它与机器人场景中的机器人、自动驾驶场景的车辆是类似的。</p>
<p>在优化问题中，一个好的初值是非常重要的。LIOSAM在启动过程中，不同的状态下位姿初值获取选用了不同的方案。</p>
<h3 id="第一帧"><a href="#第一帧" class="headerlink" title="第一帧"></a>第一帧</h3><p>当接收到第一帧点云，将IMU原始数据中的角度值作为初始姿态，位置直接用（0，0，0）。位姿初始化在文件 <code>mapOptmization.cpp</code> 中， ， 代码如下，</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//// @file： LIO-SAM/src/mapOptmization.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">updateInitialGuess</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// save current transformation before any processing</span></span><br><span class="line">    incrementalOdometryAffineFront = <span class="built_in">trans2Affine3f</span>(transformTobeMapped);</span><br><span class="line">    <span class="type">static</span> Eigen::Affine3f lastImuTransformation;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// initialization</span></span><br><span class="line">    <span class="keyword">if</span> (cloudKeyPoses3D-&gt;points.<span class="built_in">empty</span>())<span class="comment">// lidar trajectory</span></span><br><span class="line">    &#123;</span><br><span class="line">        transformTobeMapped[<span class="number">0</span>] = cloudInfo.imuRollInit;<span class="comment">// 时间早于 point_cloud, 且最接近一帧的 imu 数据中的RPY</span></span><br><span class="line">        transformTobeMapped[<span class="number">1</span>] = cloudInfo.imuPitchInit;</span><br><span class="line">        transformTobeMapped[<span class="number">2</span>] = cloudInfo.imuYawInit;</span><br><span class="line">        <span class="keyword">if</span> (!useImuHeadingInitialization)</span><br><span class="line">            transformTobeMapped[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        lastImuTransformation = pcl::<span class="built_in">getTransformation</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, cloudInfo.imuRollInit, cloudInfo.imuPitchInit, cloudInfo.imuYawInit); <span class="comment">// save imu before return;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// use imu pre-integration estimation for pose guess</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// use imu incremental estimation for pose guess (only rotation)</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述 updateInitialGuess() 函数中：</p>
<p>位姿保存在变量 transformTobeMapped[] 中，且只对角度赋值，位置值保留变量的初始化值；代码如下；</p>
<p>角度的赋初值：cloudInfo.imuRollInit &#x2F; imuPitchInit &#x2F; imuYawInit 的获取在文件 imageProjection.cpp 中，存于消息 cloud_info 中与其他消息一并发布；代码如下；</p>
<p>另还有两个参数 incrementalOdometryAffineFront 和 lastImuTransformation，lastImuTransformation 用于下一帧的雷达初始化（详见下一小节）；incrementalOdometryAffineFront在后续生成平滑的 lidar Odometry 中有应用。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//// @file： LIO-SAM/src/mapOptmization.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">allocateMemory</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; ++i)&#123;</span><br><span class="line">        transformTobeMapped[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//// @file： LIO-SAM/src/imageProjection.cpp    </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">imuDeskewInfo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...        </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="type">int</span>)imuQueue.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        sensor_msgs::Imu thisImuMsg = imuQueue[i];</span><br><span class="line">        <span class="type">double</span> currentImuTime = thisImuMsg.header.stamp.<span class="built_in">toSec</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// get roll, pitch, and yaw estimation for this scan</span></span><br><span class="line">        <span class="comment">// 持续更新 rpy 直到 IMU 时间为小于雷达时间且相距最近</span></span><br><span class="line">        <span class="keyword">if</span> (currentImuTime &lt;= timeScanCur)</span><br><span class="line">            <span class="built_in">imuRPY2rosRPY</span>(&amp;thisImuMsg, &amp;cloudInfo.imuRollInit, &amp;cloudInfo.imuPitchInit, &amp;cloudInfo.imuYawInit);</span><br><span class="line">        <span class="keyword">if</span> (currentImuTime &gt; timeScanEnd + <span class="number">0.05</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上述 imuDeskewInfo() 中的 imuRPY2rosRPY() 函数（line 23）定义在 utility.h 中，函数功能简单，只将 IMU_raw 中的 orientation 作格式转换，不多赘述。</p>
<h3 id="第二帧"><a href="#第二帧" class="headerlink" title="第二帧"></a>第二帧</h3><p>收到第二帧点云后，判断其不满足时间间隔阈值，直接返回。</p>
<h3 id="第三帧"><a href="#第三帧" class="headerlink" title="第三帧"></a>第三帧</h3><p>收到点云后，进入函数 updateInitialGuess() 中，不是第一帧后只需要关注后面的两个判断条件，<code>cloudInfo.imuAvailable, cloudInfo.odomAvailable</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//// @file： LIO-SAM/src/mapOptmization.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">updateInitialGuess</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// save current transformation before any processing</span></span><br><span class="line">    incrementalOdometryAffineFront = <span class="built_in">trans2Affine3f</span>(transformTobeMapped);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// initialization</span></span><br><span class="line">    <span class="keyword">if</span> (cloudKeyPoses3D-&gt;points.<span class="built_in">empty</span>())&#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// use imu pre-integration estimation for pose guess</span></span><br><span class="line">    <span class="keyword">if</span> (cloudInfo.odomAvailable == <span class="literal">true</span>)&#123;...&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// use imu incremental estimation for pose guess (only rotation)</span></span><br><span class="line">    <span class="keyword">if</span> (cloudInfo.imuAvailable == <span class="literal">true</span>)&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>imuAvailable,odomAvailable </code> 这两个参数同样来自于文件 <code>imageProjection.cpp  </code>  ：</p>
<ul>
<li><p>参数 <code>cloudInfo.imuAvailable</code> 是指是否收到用于畸变纠正的 <code>IMU</code> 原始数据，是一开始就有的；</p>
</li>
<li><p>参数 <code>cloudInfo.odomAvailable</code> 是指是否收到用于畸变纠正的 <code>IMU odometry</code> ，而这个 Topic 是在收到节点 <code>mapOptmization</code> 发出的 <code>lidar odometry</code> 后再下一帧处理所得（收到第一帧需要初始化）；</p>
</li>
</ul>
<p>因此进入第三个case，<code>if (cloudInfo.imuAvailable == true)&#123;...&#125;</code> 。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//// @file： LIO-SAM/src/mapOptmization.cpp</span></span><br><span class="line"><span class="type">void</span> updateInitialGue当前帧的位姿初值 `transFinal=transTobe * transIncre` <span class="built_in">ss</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// save current transformation before any processing</span></span><br><span class="line">    incrementalOdometryAffineFront = <span class="built_in">trans2Affine3f</span>(transformTobeMapped);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// initialization</span></span><br><span class="line">    ...    </span><br><span class="line">    <span class="comment">// use imu pre-integration estimation for pose guess</span></span><br><span class="line">    ...    </span><br><span class="line">    <span class="comment">// use imu incremental estimation for pose guess (only rotation)</span></span><br><span class="line">    <span class="keyword">if</span> (cloudInfo.imuAvailable == <span class="literal">true</span>)&#123;        </span><br><span class="line">        <span class="built_in">ROS_WARN</span>(<span class="string">&quot;Guess init, imuAvailable&quot;</span>);</span><br><span class="line">        Eigen::Affine3f transBack = pcl::<span class="built_in">getTransformation</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, cloudInfo.imuRollInit, cloudInfo.imuPitchInit, cloudInfo.imuYawInit);</span><br><span class="line">        Eigen::Affine3f transIncre = lastImuTransformation.<span class="built_in">inverse</span>() * transBack;</span><br><span class="line"></span><br><span class="line">        Eigen::Affine3f transTobe = <span class="built_in">trans2Affine3f</span>(transformTobeMapped);</span><br><span class="line">        Eigen::Affine3f transFinal = transTobe * transIncre;</span><br><span class="line">        pcl::<span class="built_in">getTranslationAndEulerAngles</span>(transFinal, transformTobeMapped[<span class="number">3</span>], transformTobeMapped[<span class="number">4</span>], transformTobeMapped[<span class="number">5</span>], </span><br><span class="line">                                                      transformTobeMapped[<span class="number">0</span>], transformTobeMapped[<span class="number">1</span>], transformTobeMapped[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">        lastImuTransformation = pcl::<span class="built_in">getTransformation</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, cloudInfo.imuRollInit, cloudInfo.imuPitchInit, cloudInfo.imuYawInit); <span class="comment">// save imu before return;</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这一段代码的逻辑是，通过结合上一帧的雷达位姿和两帧雷达位姿的增量来计算而得，获取当前帧的雷达位姿。</p>
<p>上一帧的雷达位姿初值 $T_{last_init}$ ：上一帧处理过程中存于变量 <code>lastImuTransformation</code> ；</p>
<p>上一帧雷达位姿优化值 $T_{last_opt}$ ：上一帧的优化位姿，存于 <code>transformTobeMapped[]</code> ，格式转换得到 <code>transTobe</code> ；</p>
<p>当前帧雷达位姿临时值 $T_{cur_temp}$ ：当前帧从 <code>IMU</code>原始数据中获取的位姿，存于 <code>transBack</code> ；</p>
<p>当前帧的雷达位姿初值 $T_{cur_init}$ ：也就是当前函数的待求值，前帧的位姿初值 <code>transFinal=transTobe * transIncre</code> &gt;。</p>
<p>两帧之间的位姿增量 $T_{between}$ ：上一帧位姿初值 $T_{last-init}$ 和当前帧雷达位姿临时值 $T_{cur_temp}$ 之间的增量（<code>transIncre</code>）；</p>
<p>用公式表示为：<br>$$<br>T_{between}&#x3D;T_{last_init}^{-1}T_{cur_temp}\T_{cur_init}&#x3D;T_{last_opt}T_{between}<br>$$<br>得到当前帧位姿初值后，再度存于 <code>transformTobeMapped[]</code> 中对其进行更新，这个参数非常重要的。</p>
<p>并同时更新<code>lastImuTransformation</code> 用于下一帧的处理。</p>
<p>注1：前面的【当前帧雷达位姿临时值】是笔者自己起的一个名字，为区别于用于后端优化的初值，而用了临时值的说法。</p>
<p>注2：这部分应用到有关矩阵右乘的知识点，主要多加注意，可参考这个问题 <a href="https://www.zhihu.com/question/263660493">矩阵左乘，右乘到底是什么意思？</a>中 <a href="https://www.zhihu.com/people/yan-fei-can-yue-tian-50">糖糖不是堂</a> 的回答。</p>
<h3 id="第四帧"><a href="#第四帧" class="headerlink" title="第四帧"></a>第四帧</h3><p>同第二帧情形，不满足时间间隔阈值，直接返回。</p>
<h3 id="第五帧"><a href="#第五帧" class="headerlink" title="第五帧"></a>第五帧</h3><p>到此时，</p>
<h2 id="雷达里程计的最高频率"><a href="#雷达里程计的最高频率" class="headerlink" title="雷达里程计的最高频率"></a>雷达里程计的最高频率</h2><p>雷达里程计并不是对每一帧点云都进行处理，这里有一个时间阈值的判断。</p>
<p><a href="">《后端优化中 雷达 位姿的初始化》</a>中所说的第二帧，是指满足时间间隔要求的第二帧，实为第三帧，收到的第二帧点云与第一帧</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//// @file： LIO-SAM/src/mapOptmization.cpp</span></span><br><span class="line"><span class="keyword">if</span> (timeLaserInfoCur - timeLastProcessing &gt;= mappingProcessInterval)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>mappingProcessInterval</code>的默认参数是0.15s，所以在默认参数下，雷达里程计不会超过1&#x2F;0.15Hz</p>
<p>参数配置文件： <code>LIO-SAM/config/params.yaml</code></p>
<h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><ul>
<li><p>每个 Topic 具体发布的数据什么含义</p>
</li>
<li><p>mapOpt 中的lio_sam&#x2F;mapping&#x2F;odometry 与 lio_sam&#x2F;mapping&#x2F;odometry_incremental有什么区别与联系?</p>
</li>
</ul>
<p><a href="https://github.com/TixiaoShan/LIO-SAM/issues/92">https://github.com/TixiaoShan/LIO-SAM/issues/92</a></p>
<ul>
<li><p>odometry&#x2F;imu 与 odometry&#x2F;imu_incremental</p>
<p>odometry&#x2F;imu_incremental，在imagerojection发布</p>
<p>odometry&#x2F;imu，在transformusion中，</p>
</li>
<li><p>transformTobeMapped 的初始化与优化历程</p>
</li>
<li><p>gtsam 中 的先验因子和 Values 有什么区别</p>
</li>
<li><p>imgProject 中用于畸变纠正的 IMU 数据 Odom 数据</p>
<p>Odom 数据 为什么用 IMU 里程计，而不用 lidar Odom？因为后者滞后</p>
<p>roll，pitch，yaw 的纠正为什么用原始IMU，而不用  IMU 里程计 中的orientation？ 尚不清楚。</p>
</li>
<li><p>addOdomFactor() 为何首帧的噪声模型参数的yaw为 PI*PI？</p>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>初雪</title>
    <url>/2018/12/20/2018-12-20-snow/</url>
    <content><![CDATA[<p>前段时间朋友圈下了一场声势浩大的初雪，除了跟北京以及在北京的我们没什么关系以外，还挺热闹的，还有人戏称道，“看来一般的雪是办不了进京证的”，有点道理。</p>
<p><img src="/MD_IMG/2018-12-20-snow.assets/640.jpeg" alt="图片"></p>
<p>翻到大学时候的写的一点东西，正是12年的这个时候，6年前了，大三了，保研的事已定，课业压力也不大，每天过得有点悠闲，经常和对门宿舍的同学M去泡图书馆。</p>
<p>不过倒是闲书看的比较多，瓷器发展历程，文学璀璨史，货币的前世今生，什么都看，似乎是一个系列的书，现在也不记得多少了，不过也没什么要紧的。不得不说，武大的新图，真的是温暖有余，晕晕乎乎昏昏沉沉，梅园食堂的饭菜是真心不悦，综合起来，还是比较适合看闲书了哈哈。</p>
<hr>
<p><strong>初雪</strong></p>
<p>（2012年12月26日上午于武大新图）</p>
<p>真庆幸，今天起了个早，见证了这个冬天的第一场雪……</p>
<p>昨晚宿舍又是一场漫谈，搞得今早起得迷迷糊糊，昏昏沉沉的，但是终于，想到图书馆的人山人海，理智战胜了懒惰。</p>
<p>脑袋里还在回想着那个奇怪的梦，慢慢吞吞地从床上爬起，当我不经心的从窗外看去，天空竟洋洋洒洒的飘起了雪，雪不大，看得出来才刚下不久，但是雪花很大，伸手都能接住一片下来。</p>
<p>人们对于第一场雪，总是有太多的不一样的情愫，尤其是像在南方长大的我们，一年难得一次下雪，几年难得一次大雪，但是此刻的我也没有时间去观赏，去感慨。拧开水龙头，就这样用冷水洗了个脸，清醒清醒，收拾收拾东西，就出门了。</p>
<p>雪越下越大，漫天飞舞一般，走在宿舍四楼的过道上，看着洒下的雪花，看着下面稀稀朗朗的人群，有打着伞的，也有尽情享受雪花飘落肩头的，很有种这才是过日子，这才是生活的味道，或者更确切的说，这是一种家的意味，这雪一下，好像一年总算完整了，生活总算圆满了，也该回家了。</p>
<p>本来还在想，自从上次从好友D那儿坑来一把伞后，就再没下过可以打伞的雨，今天终于派上用场了，但是被室友Y看见，却说是我把好好的感受给破坏了，不知道好好地享受，但是我还是想打伞，即使是打伞了，身上还是钻进一些来，这样似乎更美妙一点。一把透明的伞。</p>
<p>就着这把伞的透明，心也明朗起来，好像又换了一种心情一样。改变心情的方法有很多种，就换个头发，心情也能很久保持新鲜；当你买了件衣服，穿习惯之后，就有点不想穿回以前那些曾经也让你很舒服的衣服了，也许是旧的，其实也许根本不是旧的。一件衣服就可以把你带回以前的心情，以前的日子。现在，我很想需要全新的我自己，总想摆脱。</p>
<p>才多久的功夫，到图书馆的一路上，就已经全部盖上了雪的印记。地上的雪虽然还没留住，但楼下的车座上早已有一层不薄的雪，那些地上的黄叶上面也星星点点的有几片雪花逗留，图书馆外的那杉树（还是什么其他的树）上也白白的，金莹剔透的一层而显得烟雾缭绕，走到操场外边，应是距离的缘故，整个足球场竟是白茫茫的一片，像是积蓄了很久的一样，在那雪白之中，还有一两个人在漫步，幸而我站的远，看不见那脚印，不然会是觉得破坏了美好，又或许这样有点痕迹而因参差不齐而更加美好。这时走过来一个像是去上学的小学生，对着旁边的妈妈说操场上结冰了，透露出分外的兴奋和开心的。</p>
<p>想想曾经的我们啊，没有空调，没有热水袋，一样的也是那么早的起床，穿的严严实实去上学，还不忘从路边的水田里掰几块儿冰来用秸秆穿好，冻得要死，也不觉得好看，真不知是为了什么，好像就只为和同伴比比；要是碰上下雪，就从家找来些个瓶瓶罐罐，找那些看上去特别干净的装上，毫不夸张的说，小时候都不知道吃过多少回雪了；若是运气好点，大雪一下，就更加放肆了，往雪地里一倒，留下那丝毫不能长存的印记。</p>
<p>这些回忆用一个字来说就是—家，在外面久了，越来越多东西会被盖上家的印章，就像食堂的萝卜片儿一样，我真就吃出了家的味道；同时，在外面久了，也慢慢的要不记得—家乡—那是一种什么样的氛围了，只能感觉是一种美好—大人们闲聊，小孩儿们跳皮筋儿，还常常被妈妈骂成是“跶火坑儿”，我也不知道是什么由来—冬天一幅永恒的画面。</p>
<p>刚八点多回去拿东西的时候，雪就已经有要停的趋势了，那些没看到的人们是不是遗憾呢……</p>
<p>不知道现在外面的雪怎么样了……</p>
<hr>
<p>留下几条评论以作纪念</p>
<p><img src="/MD_IMG/2018-12-20-snow.assets/640-16895079135351.jpeg" alt="图片"></p>
<p><img src="/MD_IMG/2018-12-20-snow.assets/640-16895079135362.jpeg" alt="图片"></p>
<p><img src="/MD_IMG/2018-12-20-snow.assets/640-16895079135363.jpeg" alt="图片"></p>
<p>​                </p>
<hr>
<p>期待这个冬天的初雪见证…</p>
]]></content>
      <categories>
        <category>随笔</category>
        <category>生活记</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
</search>
